[{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@rstudio.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Davis Vaughan Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/articles/rowwise.html","id":"row-wise-iteration","dir":"Articles","previous_headings":"","what":"Row-wise iteration","title":"Row-wise iteration with slider","text":"Let’s first explore using slide() row wise iterator general. ’ll start simple data frame. pass x column slide(), iterate using window specified ., ., .complete. defaults similar purrr::map(). applied entire example data frame, map() treats list iterates columns. slide(), hand, iterates rows. consistent vctrs idea size, length atomic vector, number rows data frame matrix. slide() always returns object size input. number rows example 4, output size 4 get one row per element output. can still use arguments slide() control window size. Often, using slide() defaults enough, common iterate just one row time.","code":"example <- tibble(   x = 1:4,   y = letters[1:4] )  example #> # A tibble: 4 × 2 #>       x y     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c     #> 4     4 d slide(example$x, ~.x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4  slide(example$x, ~.x, .before = 2) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 2 3 4 slide(example, ~.x) #> [[1]] #> # A tibble: 1 × 2 #>       x y     #>   <int> <chr> #> 1     1 a     #>  #> [[2]] #> # A tibble: 1 × 2 #>       x y     #>   <int> <chr> #> 1     2 b     #>  #> [[3]] #> # A tibble: 1 × 2 #>       x y     #>   <int> <chr> #> 1     3 c     #>  #> [[4]] #> # A tibble: 1 × 2 #>       x y     #>   <int> <chr> #> 1     4 d # Current row + 2 before slide(example, ~.x, .before = 2) #> [[1]] #> # A tibble: 1 × 2 #>       x y     #>   <int> <chr> #> 1     1 a     #>  #> [[2]] #> # A tibble: 2 × 2 #>       x y     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #>  #> [[3]] #> # A tibble: 3 × 2 #>       x y     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c     #>  #> [[4]] #> # A tibble: 3 × 2 #>       x y     #>   <int> <chr> #> 1     2 b     #> 2     3 c     #> 3     4 d  # Center aligned, with no partial results slide(example, ~.x, .before = 1, .after = 1, .complete = TRUE) #> [[1]] #> NULL #>  #> [[2]] #> # A tibble: 3 × 2 #>       x y     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c     #>  #> [[3]] #> # A tibble: 3 × 2 #>       x y     #>   <int> <chr> #> 1     2 b     #> 2     3 c     #> 3     4 d     #>  #> [[4]] #> NULL"},{"path":"https://davisvaughan.github.io/slider/dev/articles/rowwise.html","id":"varying-parameter-combinations","dir":"Articles","previous_headings":"","what":"Varying parameter combinations","title":"Row-wise iteration with slider","text":"nice use tibble structured way store parameter combinations. example, store multiple rows parameter combinations row supplied runif() generate different types uniform random variables. slide() can pass parameters runif() iterating parameters row-wise. gives access data frame current row .x. data frame, access column name. Notice restriction columns data frame argument names runif(). can also done purrr::pmap(), either name parameters tibble column names function calling, access column positionally ..1, ..3, etc. third alternative works nicely use rowwise() calling mutate(). Just remember wrap result runif() list()!","code":"parameters <- tibble(   n = 1:3,   min = c(0, 10, 100),   max = c(1, 100, 1000) )  parameters #> # A tibble: 3 × 3 #>       n   min   max #>   <int> <dbl> <dbl> #> 1     1     0     1 #> 2     2    10   100 #> 3     3   100  1000 set.seed(123)  slide(parameters, ~runif(.x$n, .x$min, .x$max)) #> [[1]] #> [1] 0.2875775 #>  #> [[2]] #> [1] 80.94746 46.80792 #>  #> [[3]] #> [1] 894.7157 946.4206 141.0008 parameters %>%   rowwise() %>%   mutate(random = list(runif(n, min, max))) #> # A tibble: 3 × 4 #> # Rowwise:  #>       n   min   max random    #>   <int> <dbl> <dbl> <list>    #> 1     1     0     1 <dbl [1]> #> 2     2    10   100 <dbl [2]> #> 3     3   100  1000 <dbl [3]>"},{"path":"https://davisvaughan.github.io/slider/dev/articles/rowwise.html","id":"sliding-inside-a-mutate","dir":"Articles","previous_headings":"","what":"Sliding inside a mutate()","title":"Row-wise iteration with slider","text":"examples, consider company data set containing day sale made, number calls, n_calls, placed day, number sales resulted calls. slide()-ing inside mutate() call, scenarios can arise. First, might want slide single column. easy enough un-grouped grouped case. need apply sliding function takes data frame input slide , ’ll need way access “current” data frame mutate() acting . dplyr 1.0.0, can access cur_data(). 1 group, current data frame input , multiple groups cur_data() returns data frame corresponding current group worked . example, imagine want fit rolling linear model predicting sales number calls. robust way mutate() use cur_data() access data frame slide . Since slide() iterates row-wise, .x corresponds current slice current data frame. group day, cur_data() first correspond rows day == 1, day == 2. Notice output two clumps NULLs, proving rolling regressions “restarted” groups. past, might used . place cur_data(). . actually magrittr %>%, dplyr, issues. biggest one won’t work grouped data frames, always return entire data set rather current group’s data frame. issue , even un-grouped data frames, can’t take advantage sequential nature mutate() evaluates expressions. example, following doesn’t work . corresponds company without updated log_sales column.","code":"company <- tibble(   day = rep(c(1, 2), each = 5),   sales = sample(100, 10),   n_calls = sales + sample(1000, 10) )  company #> # A tibble: 10 × 3 #>      day sales n_calls #>    <dbl> <int>   <int> #>  1     1    25     544 #>  2     1    90     516 #>  3     1    91     740 #>  4     1    69     835 #>  5     1    98     309 #>  6     2    57     989 #>  7     2    92     682 #>  8     2     9     602 #>  9     2    72     627 #> 10     2    26     897 company %>%   mutate(sales_roll = slide_dbl(sales, mean, .before = 2, .complete = TRUE)) #> # A tibble: 10 × 4 #>      day sales n_calls sales_roll #>    <dbl> <int>   <int>      <dbl> #>  1     1    25     544       NA   #>  2     1    90     516       NA   #>  3     1    91     740       68.7 #>  4     1    69     835       83.3 #>  5     1    98     309       86   #>  6     2    57     989       74.7 #>  7     2    92     682       82.3 #>  8     2     9     602       52.7 #>  9     2    72     627       57.7 #> 10     2    26     897       35.7  company %>%   group_by(day) %>%   mutate(sales_roll = slide_dbl(sales, mean, .before = 2, .complete = TRUE)) #> # A tibble: 10 × 4 #> # Groups:   day [2] #>      day sales n_calls sales_roll #>    <dbl> <int>   <int>      <dbl> #>  1     1    25     544       NA   #>  2     1    90     516       NA   #>  3     1    91     740       68.7 #>  4     1    69     835       83.3 #>  5     1    98     309       86   #>  6     2    57     989       NA   #>  7     2    92     682       NA   #>  8     2     9     602       52.7 #>  9     2    72     627       57.7 #> 10     2    26     897       35.7 company %>%   mutate(     regressions = slide(       .x = cur_data(),       .f = ~lm(sales ~ n_calls, .x),        .before = 2,        .complete = TRUE     )   ) #> # A tibble: 10 × 4 #>      day sales n_calls regressions #>    <dbl> <int>   <int> <list>      #>  1     1    25     544 <NULL>      #>  2     1    90     516 <NULL>      #>  3     1    91     740 <lm>        #>  4     1    69     835 <lm>        #>  5     1    98     309 <lm>        #>  6     2    57     989 <lm>        #>  7     2    92     682 <lm>        #>  8     2     9     602 <lm>        #>  9     2    72     627 <lm>        #> 10     2    26     897 <lm> company %>%   group_by(day) %>%   mutate(     regressions = slide(       .x = cur_data(),       .f = ~lm(sales ~ n_calls, .x),        .before = 2,        .complete = TRUE     )   ) #> # A tibble: 10 × 4 #> # Groups:   day [2] #>      day sales n_calls regressions #>    <dbl> <int>   <int> <list>      #>  1     1    25     544 <NULL>      #>  2     1    90     516 <NULL>      #>  3     1    91     740 <lm>        #>  4     1    69     835 <lm>        #>  5     1    98     309 <lm>        #>  6     2    57     989 <NULL>      #>  7     2    92     682 <NULL>      #>  8     2     9     602 <lm>        #>  9     2    72     627 <lm>        #> 10     2    26     897 <lm> company %>%   mutate(     log_sales = log10(sales),     regressions = slide(       .x = .,       .f = ~lm(log_sales ~ n_calls, .x),        .before = 2,        .complete = TRUE     )   ) #> Error in `mutate()`: #> ! Problem while computing `regressions = slide(...)`. #> Caused by error in `model.frame.default()`: #> ! variable lengths differ (found for 'n_calls')"},{"path":"https://davisvaughan.github.io/slider/dev/articles/slider.html","id":"slide","dir":"Articles","previous_headings":"","what":"slide()","title":"Getting started with slider","text":"better understand window functions, ’ll turn first core function, slide(). slide() bit like purrr::map(). supply vector slide , .x, function apply window, .f. two things alone, slide() almost identical map(). top , can control size placement window using additional arguments slide(). example, can ask window size 3 containing “current element, well 2 ” like : ’ll notice first two elements list contain partial “incomplete” windows. default, slide() assumes want compute windows anyways, don’t care , can change .complete argument. slide() size stable, always get output size input. , partial results replaced corresponding missing value. list, NULL. Sometimes, changing placement window critical part calculation. example, might want “center alignment” equal number values current element. accomplish , can combine .argument .get centered window. ask window size 3 containing “current element, well 1 element 1 element ”. “centered” position 2 complete window current element (2), along one element (1) one (3). slide() can also perform expanding windows. type allow cumulative operations work. prose, expanding window “current element, along every element one”. construct kind window, can set .Inf. slide() type-stable, meaning always returns object type, base form slide() always returns list. far, used illustrate works, practically likely use one suffixed forms like slide_dbl() slide_int(). example, might vector sales data want compute 3 value moving average .","code":"slide(1:4, ~.x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 slide(1:4, ~.x, .before = 2) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 2 3 4 slide(1:4, ~.x, .before = 2, .complete = TRUE) #> [[1]] #> NULL #>  #> [[2]] #> NULL #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 2 3 4 slide(1:4, ~.x, .before = 1, .after = 1) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 1 2 3 #>  #> [[3]] #> [1] 2 3 4 #>  #> [[4]] #> [1] 3 4 slide(1:4, ~.x, .before = Inf) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 1 2 3 4 sales_vec <- c(2, 4, 6, 2)  slide_dbl(sales_vec, mean, .before = 2) #> [1] 2 3 4 4"},{"path":"https://davisvaughan.github.io/slider/dev/articles/slider.html","id":"slide_index","dir":"Articles","previous_headings":"","what":"slide_index()","title":"Getting started with slider","text":"make things bit interesting, let’s assume sales vector example also tied “index”, like date vector sale actually occurred. index increasing irregular, meaning “jumped” Friday Tuesday sales dates. purpose example, let’s assume online company perfectly reasonable sales Saturday Sunday (use case requires “skip ” weekends even holidays, might like {almanac}). reasonable business question ask compute 3 day moving average. different 3 value moving average computed ? expected result, side side 3 value one computed using slide_dbl() . difference shows third row, computing 3 day moving average looking back Tuesday. understand different, consider slide_dbl() . uses sales column looks “current row, along two rows ” compute result. row 3, select rows 1-3 giving date range [Thu, Tue], isn’t 3 days. correct answer look back 2 days Tuesday, 2 rows row 3. given us date window [Sun, Tue], values range included moving average calculation row 3. row range row 3, just averaging single value 6 get result. slide_dbl() doesn’t give us want unaware index column. just looks back set number values. need function “knows” index can adjust accordingly. , can use slide_index(.x, ., .f, ...) .argument pass index vector . understand slide_index() works, take look following comparison slide(). illustration, current window weekday vector printed . Notice position 3, slide() gives us “wrong” result Thursday, Friday Tuesday, just looks back 2 values. hand, slide_index() can “aware” irregular index vector. passing ., swapping look back period 2 lubridate object days(2), start range computed .- days(2), correctly computes date window [Sun, Tue] third element, capture Tuesday window. Knowing , can swap slide_dbl() slide_index_dbl() see correctly compute 3 day rolling average.","code":"index_vec <- as.Date(\"2019-08-29\") + c(0, 1, 5, 6) wday_vec <- as.character(wday(index_vec, label = TRUE))  company <- tibble(   sales = sales_vec,   index = index_vec,   wday = wday_vec )  company #> # A tibble: 4 × 3 #>   sales index      wday  #>   <dbl> <date>     <chr> #> 1     2 2019-08-29 Thu   #> 2     4 2019-08-30 Fri   #> 3     6 2019-09-03 Tue   #> 4     2 2019-09-04 Wed #> # A tibble: 4 × 5 #>   sales index      wday  roll_val roll_day #>   <dbl> <date>     <chr>    <dbl>    <dbl> #> 1     2 2019-08-29 Thu          2        2 #> 2     4 2019-08-30 Fri          3        3 #> 3     6 2019-09-03 Tue          4        6 #> 4     2 2019-09-04 Wed          4        4 wday_vec #> [1] \"Thu\" \"Fri\" \"Tue\" \"Wed\"  slide(wday_vec, ~.x, .before = 2) #> [[1]] #> [1] \"Thu\" #>  #> [[2]] #> [1] \"Thu\" \"Fri\" #>  #> [[3]] #> [1] \"Thu\" \"Fri\" \"Tue\" #>  #> [[4]] #> [1] \"Fri\" \"Tue\" \"Wed\" slide_index(wday_vec, index_vec, ~.x, .before = days(2)) #> [[1]] #> [1] \"Thu\" #>  #> [[2]] #> [1] \"Thu\" \"Fri\" #>  #> [[3]] #> [1] \"Tue\" #>  #> [[4]] #> [1] \"Tue\" \"Wed\" mutate(   company,    roll_val = slide_dbl(sales, mean, .before = 2),   roll_day = slide_index_dbl(sales, index, mean, .before = days(2)) ) #> # A tibble: 4 × 5 #>   sales index      wday  roll_val roll_day #>   <dbl> <date>     <chr>    <dbl>    <dbl> #> 1     2 2019-08-29 Thu          2        2 #> 2     4 2019-08-30 Fri          3        3 #> 3     6 2019-09-03 Tue          4        6 #> 4     2 2019-09-04 Wed          4        4"},{"path":"https://davisvaughan.github.io/slider/dev/articles/slider.html","id":"slide_period","dir":"Articles","previous_headings":"","what":"slide_period()","title":"Getting started with slider","text":"slide_index(), always returned vector size .x, idea build indices slice .x using “current element .+ number elements /”. slide_period() works bit differently. first breaks .“time blocks” period (like monthly), uses blocks define slide .x. see example, let’s expand company sales data frame. Now say want compute monthly sales, just return 1 value per month. Since 4 months, get 4 values back. really want break index “time blocks” 1 month, slide . ’s slide_period() . Since returns 4 values, number values .x, won’t fit naturally mutate() summarise() statement. find easiest way create helper function takes data frame returns one summary result one time block, call slide_period_dfr(). Now might thinking, “can dplyr lubridate!”, ’d right: things get interesting! Now want compute monthly sales, want time blocks made “current month block, plus 1 month block ”. example, month 2019-09, include 2019-08 2019-09 together rolling summary. isn’t easy way dplyr alone. slider, two ways . first slide_period_dfr(), easy adding .= 1, select current month block 1 . Depending use case, might want append results new column big_company. , can instead go back using floor_date() generate monthly groupings, slide using slide_index_dbl() lookback period 1 month.","code":"big_index_vec <- c(   as.Date(\"2019-08-30\") + 0:4,   as.Date(\"2019-11-30\") + 0:4 )  big_sales_vec <- c(2, 4, 6, 2, 8, 10, 9, 3, 5, 2)  big_company <- tibble(   sales = big_sales_vec,   index = big_index_vec )  big_company #> # A tibble: 10 × 2 #>    sales index      #>    <dbl> <date>     #>  1     2 2019-08-30 #>  2     4 2019-08-31 #>  3     6 2019-09-01 #>  4     2 2019-09-02 #>  5     8 2019-09-03 #>  6    10 2019-11-30 #>  7     9 2019-12-01 #>  8     3 2019-12-02 #>  9     5 2019-12-03 #> 10     2 2019-12-04 slide_period(big_company, big_company$index, \"month\", ~.x) #> [[1]] #> # A tibble: 2 × 2 #>   sales index      #>   <dbl> <date>     #> 1     2 2019-08-30 #> 2     4 2019-08-31 #>  #> [[2]] #> # A tibble: 3 × 2 #>   sales index      #>   <dbl> <date>     #> 1     6 2019-09-01 #> 2     2 2019-09-02 #> 3     8 2019-09-03 #>  #> [[3]] #> # A tibble: 1 × 2 #>   sales index      #>   <dbl> <date>     #> 1    10 2019-11-30 #>  #> [[4]] #> # A tibble: 4 × 2 #>   sales index      #>   <dbl> <date>     #> 1     9 2019-12-01 #> 2     3 2019-12-02 #> 3     5 2019-12-03 #> 4     2 2019-12-04 monthly_summary <- function(data) {   summarise(data, index = max(index), sales = sum(sales)) }  slide_period_dfr(   big_company,   big_company$index,   \"month\",   monthly_summary ) #> # A tibble: 4 × 2 #>   index      sales #>   <date>     <dbl> #> 1 2019-08-31     6 #> 2 2019-09-03    16 #> 3 2019-11-30    10 #> 4 2019-12-04    19 big_company %>%   mutate(monthly = floor_date(index, \"month\")) %>%   group_by(monthly) %>%   summarise(sales = sum(sales)) #> # A tibble: 4 × 2 #>   monthly    sales #>   <date>     <dbl> #> 1 2019-08-01     6 #> 2 2019-09-01    16 #> 3 2019-11-01    10 #> 4 2019-12-01    19 slide_period_dfr(   big_company,   big_company$index,   \"month\",   monthly_summary,   .before = 1 ) #> # A tibble: 4 × 2 #>   index      sales #>   <date>     <dbl> #> 1 2019-08-31     6 #> 2 2019-09-03    22 #> 3 2019-11-30    10 #> 4 2019-12-04    29 big_company %>%   mutate(     monthly = floor_date(index, \"month\"),     sales_summary = slide_index_dbl(sales, monthly, sum, .before = months(1))   ) #> # A tibble: 10 × 4 #>    sales index      monthly    sales_summary #>    <dbl> <date>     <date>             <dbl> #>  1     2 2019-08-30 2019-08-01             6 #>  2     4 2019-08-31 2019-08-01             6 #>  3     6 2019-09-01 2019-09-01            22 #>  4     2 2019-09-02 2019-09-01            22 #>  5     8 2019-09-03 2019-09-01            22 #>  6    10 2019-11-30 2019-11-01            10 #>  7     9 2019-12-01 2019-12-01            29 #>  8     3 2019-12-02 2019-12-01            29 #>  9     5 2019-12-03 2019-12-01            29 #> 10     2 2019-12-04 2019-12-01            29"},{"path":"https://davisvaughan.github.io/slider/dev/articles/tsibble.html","id":"slide","dir":"Articles","previous_headings":"","what":"slide()","title":"Converting from tsibble","text":"tsibble’s .size .align arguments roughly equivalent using ..slider. tsibble, ’d specify full width window .size, ’d specify construct window .aligning left, right, center. slider, always start “current” element, specify many elements ..current element want window. width window slider terms computed .- .+ 1. also set .complete argument slider’s slide() TRUE, default slider allows partial windows, tsibble’s version . equivalent argument tsibble .partial (note interpreted inversely ). .fill equivalent slider. slider always uses vctrs definition missing value (typed NA vectors, NULL lists). slider result NULL, tsibble result used NA (default .fill value tsibble). Specifying windows using ..might first feel bit unnatural tsibble zoo user, generally flexible. can generate irregular windows aren’t possible tsibble, like: see next section, expanding windows easy create setting ..Inf. syntax also translates naturally slide_index(), bounds window (default) computed .- ..+ ., often expressed single window size value.","code":"x <- 1:3  # The current element, and 1 before it slider::slide(x, identity, .before = 1, .complete = TRUE) #> [[1]] #> NULL #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 2 3 # Window size of 2, assume the current element is the right side of the window tsibble::slide(x, identity, .size = 2, .align = \"right\") #> [[1]] #> [1] NA #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 2 3 # The current element, along with 1 before and 3 after (if they exist) slider::slide(1:6, identity, .before = 1, .after = 3) #> [[1]] #> [1] 1 2 3 4 #>  #> [[2]] #> [1] 1 2 3 4 5 #>  #> [[3]] #> [1] 2 3 4 5 6 #>  #> [[4]] #> [1] 3 4 5 6 #>  #> [[5]] #> [1] 4 5 6 #>  #> [[6]] #> [1] 5 6"},{"path":"https://davisvaughan.github.io/slider/dev/articles/tsibble.html","id":"tile","dir":"Articles","previous_headings":"","what":"tile()","title":"Converting from tsibble","text":"Tiling uses non-overlapping windows. example, segments x 4 non-overlapping buckets, many buckets possible window size 3. direct equivalent slider, can get close slide(). tile() seems left-align index, need current element plus two .. Since non-overlapping window, want .step forward size window, three. isn’t exactly , slide() guaranteed size-stable, returning object size .x. However, purrr::compact() result drop NULL values, equivalent.","code":"x <- 1:10  tsibble::tile(x, identity, .size = 3) #> [[1]] #> [1] 1 2 3 #>  #> [[2]] #> [1] 4 5 6 #>  #> [[3]] #> [1] 7 8 9 #>  #> [[4]] #> [1] 10 result <- slider::slide(x, identity, .after = 2, .step = 3) result #> [[1]] #> [1] 1 2 3 #>  #> [[2]] #> NULL #>  #> [[3]] #> NULL #>  #> [[4]] #> [1] 4 5 6 #>  #> [[5]] #> NULL #>  #> [[6]] #> NULL #>  #> [[7]] #> [1] 7 8 9 #>  #> [[8]] #> NULL #>  #> [[9]] #> NULL #>  #> [[10]] #> [1] 10 purrr::compact(result) #> [[1]] #> [1] 1 2 3 #>  #> [[2]] #> [1] 4 5 6 #>  #> [[3]] #> [1] 7 8 9 #>  #> [[4]] #> [1] 10"},{"path":"https://davisvaughan.github.io/slider/dev/articles/tsibble.html","id":"stretch","dir":"Articles","previous_headings":"","what":"stretch()","title":"Converting from tsibble","text":"construct expanding windows tsibble, ’ve probably used stretch(). fixes initial window size, expands add observations without dropping . slider, can set .= Inf select current element plus elements one. stretch() allows set .init fix initial minimum window size: isn’t direct equivalent slider, function return NULL current window size didn’t hold enough elements:","code":"x <- 1:4  tsibble::stretch(x, identity) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 1 2 3 4 slider::slide(x, identity, .before = Inf) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 1 2 3 4 tsibble::stretch(x, identity, .init = 3) #> [[1]] #> [1] NA #>  #> [[2]] #> [1] NA #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 1 2 3 4 identity3 <- function(x) {   if (length(x) < 3) {     NULL   } else {     x   } }  slider::slide(x, identity3, .before = Inf) #> [[1]] #> NULL #>  #> [[2]] #> NULL #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 1 2 3 4"},{"path":"https://davisvaughan.github.io/slider/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Davis Vaughan. Author, maintainer. RStudio. Copyright holder, funder.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vaughan D (2022). slider: Sliding Window Functions. https://github.com/DavisVaughan/slider, https://davisvaughan.github.io/slider/.","code":"@Manual{,   title = {slider: Sliding Window Functions},   author = {Davis Vaughan},   year = {2022},   note = {https://github.com/DavisVaughan/slider, https://davisvaughan.github.io/slider/}, }"},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"slider","dir":"","previous_headings":"","what":"Sliding Window Functions","title":"Sliding Window Functions","text":"slider provides family general purpose “sliding window” functions. API purposefully similar purrr. goal functions usually compute rolling averages, cumulative sums, rolling regressions, “window” based computations. 3 core functions slider: slide() iterates data like purrr::map(), uses sliding window . type-stable, always returns result size input. slide_index() computes rolling calculation relative index. ever wanted compute something like “3 month rolling average” number days month irregular, might like function. slide_period() similar slide_index() slides relative index, first breaks index “time blocks”, like 2 month blocks time, slides .x using indices defined blocks. core functions variants purrr::map(). example, slide() slide_dbl(), slide2(), pslide(), along combinations variants might expect previously used purrr. learn three functions, read introduction vignette. also set extremely fast specialized variants slide_dbl() common use cases. include slide_sum() rolling sums slide_mean() rolling averages. index variants well, like slide_index_sum().","code":""},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Sliding Window Functions","text":"Install released version CRAN : Install development version GitHub :","code":"install.packages(\"slider\") remotes::install_github(\"DavisVaughan/slider\")"},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Sliding Window Functions","text":"help page slide() many examples, : classic example moving average. slide() handles combination ..arguments, control width window alignment. Inf, can “cumulative slide” compute cumulative expressions. think saying “give everything current element.” .complete, can decide whether .f evaluated incomplete windows. following example, requested window size 3, first two results computed windows size 1 2 partial results allowed default. .complete set TRUE, first two results computed.","code":"library(slider) # Moving average (Aligned right) # \"The current element + 2 elements before\" slide_dbl(1:5, ~mean(.x), .before = 2) #> [1] 1.0 1.5 2.0 3.0 4.0  # Align left # \"The current element + 2 elements after\" slide_dbl(1:5, ~mean(.x), .after = 2) #> [1] 2.0 3.0 4.0 4.5 5.0  # Center aligned # \"The current element + 1 element before + 1 element after\" slide_dbl(1:5, ~mean(.x), .before = 1, .after = 1) #> [1] 1.5 2.0 3.0 4.0 4.5 slide(1:4, ~.x, .before = Inf) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 1 2 3 4 slide(1:4, ~.x, .before = 2) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 2 3 4  slide(1:4, ~.x, .before = 2, .complete = TRUE) #> [[1]] #> NULL #>  #> [[2]] #> NULL #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 2 3 4"},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"data-frames","dir":"","previous_headings":"","what":"Data frames","title":"Sliding Window Functions","text":"Unlike purrr::map(), slide() iterates data frames row wise fashion. Interestingly means default slide() becomes generic row wise iterator, nice syntax accessing data frame columns. vignette specifically . makes rolling regressions trivial!","code":"mini_cars <- cars[1:4,]  slide(mini_cars, ~.x) #> [[1]] #>   speed dist #> 1     4    2 #>  #> [[2]] #>   speed dist #> 1     4   10 #>  #> [[3]] #>   speed dist #> 1     7    4 #>  #> [[4]] #>   speed dist #> 1     7   22  slide_dbl(mini_cars, ~.x$speed + .x$dist) #> [1]  6 14 11 29 library(tibble) set.seed(123)  df <- tibble(   y = rnorm(100),   x = rnorm(100) )  # Window size of 20 rows # The current row + 19 before # (see slide_index() for how to do this relative to a date vector!) df$regressions <- slide(df, ~lm(y ~ x, data = .x), .before = 19, .complete = TRUE)  df[15:25,] #> # A tibble: 11 × 3 #>         y      x regressions #>     <dbl>  <dbl> <list>      #>  1 -0.556  0.519 <NULL>      #>  2  1.79   0.301 <NULL>      #>  3  0.498  0.106 <NULL>      #>  4 -1.97  -0.641 <NULL>      #>  5  0.701 -0.850 <NULL>      #>  6 -0.473 -1.02  <lm>        #>  7 -1.07   0.118 <lm>        #>  8 -0.218 -0.947 <lm>        #>  9 -1.03  -0.491 <lm>        #> 10 -0.729 -0.256 <lm>        #> 11 -0.625  1.84  <lm>"},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"index-sliding","dir":"","previous_headings":"","what":"Index sliding","title":"Sliding Window Functions","text":"many business settings, value want compute tied index, like date vector. cases, ’ll probably want compute sliding windows relative index, using fixed window slide() provides. can use slide_index() pass .x index, ., window calculated relative index. , computing “2 day window”, probably don’t want \"2019-08-16\" \"2019-08-18\" grouped together. slide() concept index, specify window size 2, group two together. slide_index(), hand, right thing. Essentially happens get \"2019-08-18\", “looks backwards” 1 day set window boundary \"2019-08-17\". Since date position 2, \"2019-08-16\", \"2019-08-17\", included. Powerfully, can pass object .computes value .- .. means also used lubridate period object (gets even interesting use weeks() months()):","code":"x <- 1:3 i <- as.Date(c(\"2019-08-15\", \"2019-08-16\", \"2019-08-18\"))  # slide() has no concept of an \"index\" slide(x, ~.x, .before = 1) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 2 3  # \"index aware\" slide_index(x, i, ~.x, .before = 1) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 3 slide_index(x, i, ~.x, .before = lubridate::days(1)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 3"},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"period-sliding","dir":"","previous_headings":"","what":"Period sliding","title":"Sliding Window Functions","text":"slide_period() different slide_index() first breaks index “time blocks” slides .x relative blocks. example, monthly period slide , broken 4 time blocks “current block monthly data, plus one block one”. locations blocks locations used slice .x . One neat thing notice slide_period() aware distance elements .period specify. practical implication example, group 3 2019-04-01 include 2019-02-05 , 1 month group away.","code":"i <- as.Date(c(   \"2019-01-29\",    \"2019-01-30\",    \"2019-02-05\",    \"2019-04-01\",    \"2019-05-10\" ))  slide_period(i, i, \"month\", ~.x, .before = 1) #> [[1]] #> [1] \"2019-01-29\" \"2019-01-30\" #>  #> [[2]] #> [1] \"2019-01-29\" \"2019-01-30\" \"2019-02-05\" #>  #> [[3]] #> [1] \"2019-04-01\" #>  #> [[4]] #> [1] \"2019-04-01\" \"2019-05-10\""},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"inspiration","dir":"","previous_headings":"","what":"Inspiration","title":"Sliding Window Functions","text":"package inspired heavily SQL’s window functions. API similar, general can iterate kind R object. multiple attempts creating sliding window functions (personally created rollify(), worked little bit tsibble::slide() Earo Wang). zoo::rollapply() tibbletime::rollify() tsibble::slide() believe slider next iteration . reasons : , API intuitive, flexible ..let completely control entry point (opposed fixed entry points like \"center\", \"left\", etc. objectively faster written purely C. slide_vec() can return kind object, limited suffixed versions: _dbl, _int, etc. iterates rowwise data frames, consistent vctrs framework. believe overall consistent, backed theory can always justify sliding window generated combination parameters. Earo spoken, mutually agreed best deprecate tsibble::slide() favor slider::slide(). Additionally, data.table’s non-equi joins pretty much solution problem slide_index() tries solve. solution robust quite fast, nice benchmark slider. slider trying solve much narrower problem, API focused.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"performance","dir":"","previous_headings":"","what":"Performance","title":"Sliding Window Functions","text":"Like purrr::map(), core functions slider, slide() slide_index(), optimized C fast possible, overhead involved calling .f repeatedly. functions meant general purpose possible, cost performance. means slider can used abstract computations, like rolling regressions, custom function want use rolling fashion. slider also provides specialized functions common use cases, slide_mean(), slide_index_sum(). compute corresponding metric C level, using specialized algorithm, often much faster slide_dbl(x, fn) equivalent.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Sliding Window Functions","text":"’ve found following references useful understand window functions: Postgres SQL documentation dbplyr window function vignette SQLite documentation - flowchart Vertica Rows vs Range discussion","code":""},{"path":"https://davisvaughan.github.io/slider/dev/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Sliding Window Functions","text":"Please note slider project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/block.html","id":null,"dir":"Reference","previous_headings":"","what":"Break a vector into blocks — block","title":"Break a vector into blocks — block","text":"block() breaks -ndex period, uses define indices chop x . example, can split x monthly yearly blocks. Combined purrr::map(), way iterate vector \"time blocks\".","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/block.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Break a vector into blocks — block","text":"","code":"block(x, i, period, every = 1L, origin = NULL)"},{"path":"https://davisvaughan.github.io/slider/dev/reference/block.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Break a vector into blocks — block","text":"x [vector] vector block. [Date / POSIXct / POSIXlt] datetime index block . 3 restrictions index: size index must match size x, recycled common size. index must increasing vector, duplicate values allowed. index missing values. period [character(1)] string defining period group . Valid inputs can roughly broken : \"year\", \"quarter\", \"month\", \"week\", \"day\" \"hour\", \"minute\", \"second\", \"millisecond\" \"yweek\", \"mweek\" \"yday\", \"mday\" every [positive integer(1)] number periods group together. example, period set \"year\" every value 2, years 1970 1971 placed group. origin [Date(1) / POSIXct(1) / POSIXlt(1) / NULL] reference date time value. default left NULL epoch time 1970-01-01 00:00:00, time zone index. generally used define anchor time count , relevant every value > 1.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/block.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Break a vector into blocks — block","text":"vector fulfilling following invariants: vec_size(block(x)) == vec_size(unique(warp::warp_boundary())) vec_ptype(block(x)) == list() vec_ptype(block(x)[[1]]) == vec_ptype(x)","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/block.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Break a vector into blocks — block","text":"block() determines indices block warp::warp_boundary(), splits x indices using vctrs::vec_chop(). Like slide(), block() splits data frame x values row wise.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/block.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Break a vector into blocks — block","text":"","code":"x <- 1:6 i <- as.Date(\"2019-01-01\") + c(-2:2, 31)  block(i, i, period = \"year\") #> [[1]] #> [1] \"2018-12-30\" \"2018-12-31\" #>  #> [[2]] #> [1] \"2019-01-01\" \"2019-01-02\" \"2019-01-03\" \"2019-02-01\" #>   # Data frames are split row wise df <- data.frame(x = x, i = i) block(df, i, period = \"month\") #> [[1]] #>   x          i #> 1 1 2018-12-30 #> 2 2 2018-12-31 #>  #> [[2]] #>   x          i #> 1 3 2019-01-01 #> 2 4 2019-01-02 #> 3 5 2019-01-03 #>  #> [[3]] #>   x          i #> 1 6 2019-02-01 #>   # Iterate over these blocks to apply a function over # non-overlapping period blocks. For example, to compute a # mean over yearly or monthly blocks. vapply(block(x, i, \"year\"), mean, numeric(1)) #> [1] 1.5 4.5 vapply(block(x, i, \"month\"), mean, numeric(1)) #> [1] 1.5 4.0 6.0  # block by every 2 months, ensuring that we start counting # the 1st of the 2 months from `2019-01-01` block(i, i, period = \"month\", every = 2, origin = as.Date(\"2019-01-01\")) #> [[1]] #> [1] \"2018-12-30\" \"2018-12-31\" #>  #> [[2]] #> [1] \"2019-01-01\" \"2019-01-02\" \"2019-01-03\" \"2019-02-01\" #>   # Use the `origin` to instead start counting from `2018-12-01`, meaning # that [2018-12, 2019-01] gets bucketed together. block(i, i, period = \"month\", every = 2, origin = as.Date(\"2018-12-01\")) #> [[1]] #> [1] \"2018-12-30\" \"2018-12-31\" \"2019-01-01\" \"2019-01-02\" \"2019-01-03\" #>  #> [[2]] #> [1] \"2019-02-01\" #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop.html","id":null,"dir":"Reference","previous_headings":"","what":"Hop — hop","title":"Hop — hop","text":"hop() lower level engine powers slide() (least theory). slightly different invariants slide(), useful either need hand craft boundary locations, want compute result size different .x.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hop — hop","text":"","code":"hop(.x, .starts, .stops, .f, ...)  hop_vec(.x, .starts, .stops, .f, ..., .ptype = NULL)"},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hop — hop","text":".x [vector] vector iterate apply .f . .starts, .stops [integer] Vectors boundary locations make windows bucket .x . .starts .stops recycled common size, common size size result. vectors integer locations along .x, --bounds values allowed. .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hop — hop","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop.html","id":"hop-","dir":"Reference","previous_headings":"","what":"hop()","title":"Hop — hop","text":"vec_size(hop(.x, .starts, .stops)) == vec_size_common(.starts, .stops) vec_ptype(hop(.x, .starts, .stops)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop.html","id":"hop-vec-","dir":"Reference","previous_headings":"","what":"hop_vec()","title":"Hop — hop","text":"vec_size(hop_vec(.x, .starts, .stops)) == vec_size_common(.starts, .stops) vec_size(hop_vec(.x, .starts, .stops)[[1]]) == 1L vec_ptype(hop_vec(.x, .starts, .stops, .ptype = ptype)) == ptype","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hop — hop","text":"hop() close faster version :   , hop_index() often useful function. hop() mainly exists API completeness. main difference start stop values make ranges possible locations along .x, enforced locations actually exist along .x. example, hop() can following, error vec_slice() 0L bounds.   hop() allows bounds values fully compatible slide(). always possible construct hop() call slide() call. example, following equivalent:","code":"map2(   .starts,   .stops,   function(start, stop) {     x_slice <- vec_slice(.x, start:stop)     .f(x_slice, ...)   } ) hop(c(\"a\", \"b\"), .starts = 0L, .stops = 1L, ~.x) #> [[1]] #> [1] \"a\" slide(1:2, ~.x, .before = 1)  hop(1:2, .starts = c(0, 1), .stops = c(1, 2), ~.x)  #> [[1]] #> [1] 1 #> #> [[2]] #> [1] 1 2"},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hop — hop","text":"","code":"# `hop()` let's you manually specify locations to apply `.f` at. hop(1:3, .starts = c(1, 3), .stops = 3, ~.x) #> [[1]] #> [1] 1 2 3 #>  #> [[2]] #> [1] 3 #>   # `hop()`'s start/stop locations are allowed to be out of bounds relative # to the size of `.x`. hop(   mtcars,   .starts = c(-1, 3),   .stops  = c(2, 6),   ~.x ) #> [[1]] #>               mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4 #> Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4 #>  #> [[2]] #>                    mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 #> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 #> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 #> Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop2.html","id":null,"dir":"Reference","previous_headings":"","what":"Hop along multiple inputs simultaneously — hop2","title":"Hop along multiple inputs simultaneously — hop2","text":"hop2() phop() represent combination slide2() pslide() hop(), allowing iterate multiple vectors , hopping along using boundaries defined .starts .stops.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hop along multiple inputs simultaneously — hop2","text":"","code":"hop2(.x, .y, .starts, .stops, .f, ...)  hop2_vec(.x, .y, .starts, .stops, .f, ..., .ptype = NULL)  phop(.l, .starts, .stops, .f, ...)  phop_vec(.l, .starts, .stops, .f, ..., .ptype = NULL)"},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hop along multiple inputs simultaneously — hop2","text":".x, .y [vector] Vectors iterate . Vectors size 1 recycled. .starts, .stops [integer] Vectors boundary locations make windows bucket .x . .starts .stops recycled common size, common size size result. vectors integer locations along .x, --bounds values allowed. .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types. .l [list] list vectors. length .l determines number arguments .f called . .l names, used named arguments .f. Elements .l size 1 recycled.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hop along multiple inputs simultaneously — hop2","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop2.html","id":"hop-","dir":"Reference","previous_headings":"","what":"hop2()","title":"Hop along multiple inputs simultaneously — hop2","text":"vec_size(hop2(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops) vec_ptype(hop2(.x, .y, .starts, .stops)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop2.html","id":"hop-vec-","dir":"Reference","previous_headings":"","what":"hop2_vec()","title":"Hop along multiple inputs simultaneously — hop2","text":"vec_size(hop2_vec(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops) vec_size(hop2_vec(.x, .y, .starts, .stops)[[1]]) == 1L vec_ptype(hop2_vec(.x, .y, .starts, .stops, .ptype = ptype)) == ptype","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop2.html","id":"phop-","dir":"Reference","previous_headings":"","what":"phop()","title":"Hop along multiple inputs simultaneously — hop2","text":"vec_size(phop(.l, .starts, .stops)) == vec_size_common(.starts, .stops) vec_ptype(phop(.l, .starts, .stops)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop2.html","id":"phop-vec-","dir":"Reference","previous_headings":"","what":"phop_vec()","title":"Hop along multiple inputs simultaneously — hop2","text":"vec_size(phop_vec(.l, .starts, .stops)) == vec_size_common(.starts, .stops) vec_size(phop_vec(.l, .starts, .stops)[[1]]) == 1L vec_ptype(phop_vec(.l, .starts, .stops, .ptype = ptype)) == ptype","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hop along multiple inputs simultaneously — hop2","text":"","code":"hop2(1:2, 3:4, .starts = 1, .stops = c(2, 1), ~c(x = .x, y = .y)) #> [[1]] #> x1 x2 y1 y2  #>  1  2  3  4  #>  #> [[2]] #> x y  #> 1 3  #>   phop(  list(1, 2:4, 5:7),  .starts = c(0, 1),  .stops  = c(2, 4),  ~c(x = ..1, y = ..2, z = ..3) ) #> [[1]] #> x1 x2 y1 y2 z1 z2  #>  1  1  2  3  5  6  #>  #> [[2]] #> x1 x2 x3 y1 y2 y3 z1 z2 z3  #>  1  1  1  2  3  4  5  6  7  #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Hop relative to an index — hop_index","title":"Hop relative to an index — hop_index","text":"hop_index() lower level engine powers slide_index(). slightly different invariants slide_index(), useful either need hand craft boundary values, want compute result size different .x.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hop relative to an index — hop_index","text":"","code":"hop_index(.x, .i, .starts, .stops, .f, ...)  hop_index_vec(.x, .i, .starts, .stops, .f, ..., .ptype = NULL)"},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hop relative to an index — hop_index","text":".x [vector] vector iterate apply .f . .[vector] index vector determines window sizes. fairly common supply date vector index, required. 3 restrictions index: size index must match size .x, recycled common size. index must increasing vector, duplicate values allowed. index missing values. .starts, .stops [vector] Vectors boundary values make windows bucket .. .starts .stops recycled common size, common size size result. vectors type .. boundaries inclusive, meaning slice .x used call .f .>= start & .<= stop returns TRUE. .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hop relative to an index — hop_index","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index.html","id":"hop-index-","dir":"Reference","previous_headings":"","what":"hop_index()","title":"Hop relative to an index — hop_index","text":"vec_size(hop_index(.x, .starts, .stops)) == vec_size_common(.starts, .stops) vec_ptype(hop_index(.x, .starts, .stops)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index.html","id":"hop-index-vec-","dir":"Reference","previous_headings":"","what":"hop_index_vec()","title":"Hop relative to an index — hop_index","text":"vec_size(hop_index_vec(.x, .starts, .stops)) == vec_size_common(.starts, .stops) vec_size(hop_index_vec(.x, .starts, .stops)[[1]]) == 1L vec_ptype(hop_index_vec(.x, .starts, .stops, .ptype = ptype)) == ptype","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hop relative to an index — hop_index","text":"","code":"library(vctrs) library(lubridate, warn.conflicts = FALSE) #> Loading required package: timechange  # --------------------------------------------------------------------------- # Returning a size smaller than `.x`  i <- as.Date(\"2019-01-25\") + c(0, 1, 2, 3, 10, 20, 35, 42, 45)  # slide_index() allows you to slide relative to `i` slide_index(i, i, ~.x, .before = weeks(1)) #> [[1]] #> [1] \"2019-01-25\" #>  #> [[2]] #> [1] \"2019-01-25\" \"2019-01-26\" #>  #> [[3]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" #>  #> [[4]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" #>  #> [[5]] #> [1] \"2019-01-28\" \"2019-02-04\" #>  #> [[6]] #> [1] \"2019-02-14\" #>  #> [[7]] #> [1] \"2019-03-01\" #>  #> [[8]] #> [1] \"2019-03-01\" \"2019-03-08\" #>  #> [[9]] #> [1] \"2019-03-08\" \"2019-03-11\" #>   # But you might be more interested in coarser summaries. This groups # by year-month and computes 2 `.f` on 2 month windows. i_yearmonth <- year(i) + (month(i) - 1) / 12 slide_index(i, i_yearmonth, ~.x, .before = 1) #> [[1]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" #>  #> [[2]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" #>  #> [[3]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" #>  #> [[4]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" #>  #> [[5]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" \"2019-02-04\" #> [6] \"2019-02-14\" #>  #> [[6]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" \"2019-02-04\" #> [6] \"2019-02-14\" #>  #> [[7]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" \"2019-02-04\" #> [6] \"2019-02-14\" \"2019-03-01\" \"2019-03-08\" \"2019-03-11\" #>  #> [[8]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" \"2019-02-04\" #> [6] \"2019-02-14\" \"2019-03-01\" \"2019-03-08\" \"2019-03-11\" #>  #> [[9]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" \"2019-02-04\" #> [6] \"2019-02-14\" \"2019-03-01\" \"2019-03-08\" \"2019-03-11\" #>   # ^ This works nicely when working with dplyr if you are trying to create # a new column in a data frame, but you'll notice that there are really only # 3 months, so only 3 values are being calculated. If you only want to return # a vector of those 3 values, you can use `hop_index()`. You'll have to # hand craft the boundaries, but this is a general strategy # I've found useful: first_start <- floor_date(i[1], \"months\") last_stop <- ceiling_date(i[length(i)], \"months\") dates <- seq(first_start, last_stop, \"1 month\") inner <- dates[2:(length(dates) - 1L)] starts <- vec_c(first_start, inner) stops <- vec_c(inner - 1, last_stop)  hop_index(i, i, starts, stops, ~.x) #> [[1]] #> [1] \"2019-01-25\" \"2019-01-26\" \"2019-01-27\" \"2019-01-28\" #>  #> [[2]] #> [1] \"2019-02-04\" \"2019-02-14\" #>  #> [[3]] #> [1] \"2019-03-01\" \"2019-03-08\" \"2019-03-11\" #>   # --------------------------------------------------------------------------- # Non-existant dates with `lubridate::months()`  # Imagine you want to compute a 1 month rolling average on this # irregular daily data. i <- vec_c(as.Date(\"2019-02-27\") + 0:3, as.Date(\"2019-03-27\") + 0:5) x <- rnorm(vec_seq_along(i))  # You might try `slide_index()` like this, but you'd run into this error library(rlang)  with_options(   catch_cnd(     slide_index(x, i, mean, .before = months(1))   ),   rlang_backtrace_on_error = current_env() ) #> <error/slider_error_generated_endpoints_cannot_be_na> #> Error in `stop_slider()`: #> ! Endpoints generated by `.before` cannot be `NA`. #> ℹ They are `NA` at locations: 7, 8, 9. #> --- #> Backtrace: #>   1. pkgdown::build_site_github_pages(new_process = FALSE, install = FALSE) #>   2. pkgdown::build_site(...) #>   3. pkgdown:::build_site_local(...) #>   4. pkgdown::build_reference(...) #>   5. purrr::map(...) #>   6. pkgdown (local) .f(.x[[i]], ...) #>   8. pkgdown:::data_reference_topic(...) #>   9. pkgdown:::run_examples(...) #>  10. pkgdown:::highlight_examples(code, topic, env = env) #>  11. downlit::evaluate_and_highlight(...) #>  12. evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #>  13. evaluate:::evaluate_call(...) #>  23. evaluate:::eval_with_user_handlers(expr, envir, enclos, user_handlers) #>  24. base::eval(expr, envir, enclos) #>  25. base::eval(expr, envir, enclos) #>  34. slider::slide_index(x, i, mean, .before = months(1)) #>  35. slider:::slide_index_impl(...) #>  36. slider:::slide_index_common(...) #>  37. slider:::slide_index_info(...) #>  38. slider:::compute_ranges(...) #>  39. slider:::check_generated_endpoints_cannot_be_na(starts, before_arg) #>  40. slider:::stop_generated_endpoints_cannot_be_na(...) #>  41. slider:::stop_endpoints(...) #>  42. slider:::stop_slider(message, class = c(class, \"slider_error_endpoints\"), ...)  # This is because when you actually compute the `.i - .before` sequence, # you hit non-existant dates. i.e. `\"2019-03-29\" - months(1)` doesn't exist. i - months(1) #>  [1] \"2019-01-27\" \"2019-01-28\" \"2019-02-01\" \"2019-02-02\" \"2019-02-27\" #>  [6] \"2019-02-28\" NA           NA           NA           \"2019-03-01\"  # To get around this, lubridate provides `add_with_rollback()`, # and the shortcut operation `%m-%`, which subtracts the month, then rolls # forward/backward if it hits an `NA`. You can manually generate boundaries, # then provide them to `hop_index()`. starts <- i %m-% months(1) stops <- i  hop_index(x, i, starts, stops, mean) #> [[1]] #> [1] 0.5996394 #>  #> [[2]] #> [1] 0.1675974 #>  #> [[3]] #> [1] -0.1796386 #>  #> [[4]] #> [1] 0.1930498 #>  #> [[5]] #> [1] 0.0125638 #>  #> [[6]] #> [1] 0.01108594 #>  #> [[7]] #> [1] -0.3063278 #>  #> [[8]] #> [1] -0.2691515 #>  #> [[9]] #> [1] -0.2614301 #>  #> [[10]] #> [1] -0.2587143 #>   hop_index(i, i, starts, stops, ~.x) #> [[1]] #> [1] \"2019-02-27\" #>  #> [[2]] #> [1] \"2019-02-27\" \"2019-02-28\" #>  #> [[3]] #> [1] \"2019-02-27\" \"2019-02-28\" \"2019-03-01\" #>  #> [[4]] #> [1] \"2019-02-27\" \"2019-02-28\" \"2019-03-01\" \"2019-03-02\" #>  #> [[5]] #> [1] \"2019-02-27\" \"2019-02-28\" \"2019-03-01\" \"2019-03-02\" \"2019-03-27\" #>  #> [[6]] #> [1] \"2019-02-28\" \"2019-03-01\" \"2019-03-02\" \"2019-03-27\" \"2019-03-28\" #>  #> [[7]] #> [1] \"2019-02-28\" \"2019-03-01\" \"2019-03-02\" \"2019-03-27\" \"2019-03-28\" #> [6] \"2019-03-29\" #>  #> [[8]] #> [1] \"2019-02-28\" \"2019-03-01\" \"2019-03-02\" \"2019-03-27\" \"2019-03-28\" #> [6] \"2019-03-29\" \"2019-03-30\" #>  #> [[9]] #> [1] \"2019-02-28\" \"2019-03-01\" \"2019-03-02\" \"2019-03-27\" \"2019-03-28\" #> [6] \"2019-03-29\" \"2019-03-30\" \"2019-03-31\" #>  #> [[10]] #> [1] \"2019-03-01\" \"2019-03-02\" \"2019-03-27\" \"2019-03-28\" \"2019-03-29\" #> [6] \"2019-03-30\" \"2019-03-31\" \"2019-04-01\" #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index2.html","id":null,"dir":"Reference","previous_headings":"","what":"Hop along multiple inputs simultaneously relative to an index — hop_index2","title":"Hop along multiple inputs simultaneously relative to an index — hop_index2","text":"hop_index2() phop_index() represent combination slide2() pslide() hop_index(), allowing iterate multiple vectors , relative .-ndex boundaries defined .starts .stops.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hop along multiple inputs simultaneously relative to an index — hop_index2","text":"","code":"hop_index2(.x, .y, .i, .starts, .stops, .f, ...)  hop_index2_vec(.x, .y, .i, .starts, .stops, .f, ..., .ptype = NULL)  phop_index(.l, .i, .starts, .stops, .f, ...)  phop_index_vec(.l, .i, .starts, .stops, .f, ..., .ptype = NULL)"},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hop along multiple inputs simultaneously relative to an index — hop_index2","text":".x, .y [vector] Vectors iterate . Vectors size 1 recycled. .[vector] index vector determines window sizes. fairly common supply date vector index, required. 3 restrictions index: size index must match size .x, recycled common size. index must increasing vector, duplicate values allowed. index missing values. .starts, .stops [vector] Vectors boundary values make windows bucket .. .starts .stops recycled common size, common size size result. vectors type .. boundaries inclusive, meaning slice .x used call .f .>= start & .<= stop returns TRUE. .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types. .l [list] list vectors. length .l determines number arguments .f called . .l names, used named arguments .f. Elements .l size 1 recycled.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hop along multiple inputs simultaneously relative to an index — hop_index2","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index2.html","id":"hop-index-","dir":"Reference","previous_headings":"","what":"hop_index2()","title":"Hop along multiple inputs simultaneously relative to an index — hop_index2","text":"vec_size(hop_index2(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops) vec_ptype(hop_index2(.x, .y, .starts, .stops)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index2.html","id":"hop-index-vec-","dir":"Reference","previous_headings":"","what":"hop_index2_vec()","title":"Hop along multiple inputs simultaneously relative to an index — hop_index2","text":"vec_size(hop_index2_vec(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops) vec_size(hop_index2_vec(.x, .y, .starts, .stops)[[1]]) == 1L vec_ptype(hop_index2_vec(.x, .y, .starts, .stops, .ptype = ptype)) == ptype","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index2.html","id":"phop-index-","dir":"Reference","previous_headings":"","what":"phop_index()","title":"Hop along multiple inputs simultaneously relative to an index — hop_index2","text":"vec_size(phop_index(.l, .starts, .stops)) == vec_size_common(.starts, .stops) vec_ptype(phop_index(.l, .starts, .stops)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index2.html","id":"phop-index-vec-","dir":"Reference","previous_headings":"","what":"phop_index_vec()","title":"Hop along multiple inputs simultaneously relative to an index — hop_index2","text":"vec_size(phop_index_vec(.l, .starts, .stops)) == vec_size_common(.starts, .stops) vec_size(phop_index_vec(.l, .starts, .stops)[[1]]) == 1L vec_ptype(phop_index_vec(.l, .starts, .stops, .ptype = ptype)) == ptype","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/hop_index2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hop along multiple inputs simultaneously relative to an index — hop_index2","text":"","code":"# Notice that `i` is an irregular index! x <- 1:5 i <- as.Date(\"2019-08-15\") + c(0:1, 4, 6, 7)  # Manually create starts/stops. They don't have to be equally spaced, # and they don't have to be the same size as `.x` or `.i`. starts <- as.Date(c(\"2019-08-15\", \"2019-08-18\")) stops <- as.Date(c(\"2019-08-16\", \"2019-08-23\"))  # The output size is equal to the common size of `.starts` and `.stops` hop_index2(x, i, i, starts, stops, ~data.frame(x = .x, y = .y)) #> [[1]] #>   x          y #> 1 1 2019-08-15 #> 2 2 2019-08-16 #>  #> [[2]] #>   x          y #> 1 3 2019-08-19 #> 2 4 2019-08-21 #> 3 5 2019-08-22 #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/index-arithmetic.html","id":null,"dir":"Reference","previous_headings":"","what":"Index arithmetic — index-arithmetic","title":"Index arithmetic — index-arithmetic","text":"slider_plus() slider_minus() developer functions used register special double dispatch methods control ..subtracted added .. allow developers overcome restrictions around + - custom S3 types involved. used package authors creating new index types. slider_plus() allows override default behavior .+ .. writing S3 method, x ., y .. slider_minus() allows override default behavior .- .. writing S3 method, x ., y .. generics bit special. work similarly vctrs::vec_ptype2() double dispatch methods dispatch types x y. write S3 method generics, write export S3 method form:   Inheritance considered method lookup, use NextMethod() within method.","code":"slider_plus.x_class.y_class <- function(x, y) {   # My method }"},{"path":"https://davisvaughan.github.io/slider/dev/reference/index-arithmetic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Index arithmetic — index-arithmetic","text":"","code":"slider_plus(x, y)  slider_minus(x, y)"},{"path":"https://davisvaughan.github.io/slider/dev/reference/index-arithmetic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Index arithmetic — index-arithmetic","text":"x, y [vector] Two vectors add subtract. x always index, .. slider_plus(), y .. slider_minus(), y ..","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/index-arithmetic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Index arithmetic — index-arithmetic","text":"slider_plus(), x adding y. slider_minus(), x subtracting y. result always type size x.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/index-arithmetic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Index arithmetic — index-arithmetic","text":"","code":"slider_plus(1, 2) #> [1] 3 slider_minus(1, 2) #> [1] -1"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide.html","id":null,"dir":"Reference","previous_headings":"","what":"Slide — slide","title":"Slide — slide","text":"slide() iterates .x using sliding window, applying .f sub-window .x.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slide — slide","text":"","code":"slide(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L, .complete = FALSE)  slide_vec(   .x,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE,   .ptype = NULL )  slide_dbl(   .x,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  slide_int(   .x,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  slide_lgl(   .x,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  slide_chr(   .x,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  slide_dfr(   .x,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\") )  slide_dfc(   .x,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slide — slide","text":".x [vector] vector iterate apply .f . .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. ., .[integer(1) / Inf] number values current element include sliding window. Set Inf select elements current element. Negative values allowed, allows \"look forward\" current element used .value, \"look backwards\" used .. .step [positive integer(1)] number elements shift window forward function calls. .complete [logical(1)] function evaluated complete windows ? FALSE, default, partial computations allowed. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types. .names_to controls input names supplied .... default, input names zapped. string, specifies column input names copied. names often useful identify rows original input. column name supplied ... named, integer column used instead. NULL, input names used row names. .name_repair One \"unique\", \"universal\", \"check_unique\", \"unique_quiet\",  \"universal_quiet\". See vec_as_names() meaning options. vec_rbind(), repair function applied inputs separately. vec_rbind() needs align columns binding rows, thus needs inputs unique names. hand, vec_cbind() applies repair function inputs concatenated together final data frame. Hence vec_cbind() allows permissive minimal names repair. .size , NULL, default, determine number rows vec_cbind() output using tidyverse recycling rules. Alternatively, specify desired number rows, inputs length 1 recycled appropriately.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slide — slide","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide.html","id":"slide-","dir":"Reference","previous_headings":"","what":"slide()","title":"Slide — slide","text":"vec_size(slide(.x)) == vec_size(.x) vec_ptype(slide(.x)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide.html","id":"slide-vec-and-slide-variants","dir":"Reference","previous_headings":"","what":"slide_vec() and slide_*() variants","title":"Slide — slide","text":"vec_size(slide_vec(.x)) == vec_size(.x) vec_size(slide_vec(.x)[[1]]) == 1L vec_ptype(slide_vec(.x, .ptype = ptype)) == ptype","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Slide — slide","text":"Unlike lapply() purrr::map(), construct calls like   equivalent slide() looks like   approximately   except case data frames arrays, iterated row-wise. .x names, output preserve names. Using vctrs::vec_cast(), output .f automatically cast type required variant slide_*() used.","code":".f(.x[[i]], ...) .f(vctrs::vec_slice(.x, i), ...) .f(.x[i], ...)"},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slide — slide","text":"","code":"# The defaults work similarly to `map()` slide(1:5, ~.x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>   # Use `.before`, `.after`, and `.step` to control the window slide(1:5, ~.x, .before = 1) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 2 3 #>  #> [[4]] #> [1] 3 4 #>  #> [[5]] #> [1] 4 5 #>   # This can be used for rolling means slide_dbl(rnorm(5), mean, .before = 2) #> [1] -0.6541502 -0.3595521 -0.1784145  0.1162126  0.4802930  # Or more flexible rolling operations slide(rnorm(5), ~ .x - mean(.x), .before = 2) #> [[1]] #> [1] 0 #>  #> [[2]] #> [1]  0.6822996 -0.6822996 #>  #> [[3]] #> [1]  0.5486432 -0.8159560  0.2673129 #>  #> [[4]] #> [1] -0.52169497  0.56157395 -0.03987897 #>  #> [[5]] #> [1] -0.08600535 -0.68745827  0.77346362 #>   # `.after` allows you to \"align to the left\" rather than the right slide(1:5, ~.x, .after = 2) #> [[1]] #> [1] 1 2 3 #>  #> [[2]] #> [1] 2 3 4 #>  #> [[3]] #> [1] 3 4 5 #>  #> [[4]] #> [1] 4 5 #>  #> [[5]] #> [1] 5 #>   # And a mixture of `.before` and `.after` # allows you complete control over the exact alignment. # Below, \"center alignment\" is used. slide(1:5, ~.x, .before = 1, .after = 1) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 1 2 3 #>  #> [[3]] #> [1] 2 3 4 #>  #> [[4]] #> [1] 3 4 5 #>  #> [[5]] #> [1] 4 5 #>   # The `.step` controls how the window is shifted along `.x`, # allowing you to \"skip\" iterations if you only need a less granular result slide(1:10, ~.x, .before = 2, .step = 3) #> [[1]] #> [1] 1 #>  #> [[2]] #> NULL #>  #> [[3]] #> NULL #>  #> [[4]] #> [1] 2 3 4 #>  #> [[5]] #> NULL #>  #> [[6]] #> NULL #>  #> [[7]] #> [1] 5 6 7 #>  #> [[8]] #> NULL #>  #> [[9]] #> NULL #>  #> [[10]] #> [1]  8  9 10 #>   # `.complete` controls whether or not partial results are computed. # By default, they are, but setting `.complete = TRUE` restricts # `slide()` to only evaluate the function where a complete window exists. slide(1:5, ~.x, .before = 2, .after = 1) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 1 2 3 #>  #> [[3]] #> [1] 1 2 3 4 #>  #> [[4]] #> [1] 2 3 4 5 #>  #> [[5]] #> [1] 3 4 5 #>  slide(1:5, ~.x, .before = 2, .after = 1, .complete = TRUE) #> [[1]] #> NULL #>  #> [[2]] #> NULL #>  #> [[3]] #> [1] 1 2 3 4 #>  #> [[4]] #> [1] 2 3 4 5 #>  #> [[5]] #> NULL #>   # --------------------------------------------------------------------------- # Data frames  # Data frames are iterated over rowwise mtcars_rowwise <- slide(mtcars, ~.x) mtcars_rowwise[1:3] #> $`Mazda RX4` #>           mpg cyl disp  hp drat   wt  qsec vs am gear carb #> Mazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4 #>  #> $`Mazda RX4 Wag` #>               mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4 #>  #> $`Datsun 710` #>             mpg cyl disp hp drat   wt  qsec vs am gear carb #> Datsun 710 22.8   4  108 93 3.85 2.32 18.61  1  1    4    1 #>   # This means that any column name is easily accessible slide_dbl(mtcars, ~.x$mpg + .x$cyl) #>           Mazda RX4       Mazda RX4 Wag          Datsun 710      Hornet 4 Drive  #>                27.0                27.0                26.8                27.4  #>   Hornet Sportabout             Valiant          Duster 360           Merc 240D  #>                26.7                24.1                22.3                28.4  #>            Merc 230            Merc 280           Merc 280C          Merc 450SE  #>                26.8                25.2                23.8                24.4  #>          Merc 450SL         Merc 450SLC  Cadillac Fleetwood Lincoln Continental  #>                25.3                23.2                18.4                18.4  #>   Chrysler Imperial            Fiat 128         Honda Civic      Toyota Corolla  #>                22.7                36.4                34.4                37.9  #>       Toyota Corona    Dodge Challenger         AMC Javelin          Camaro Z28  #>                25.5                23.5                23.2                21.3  #>    Pontiac Firebird           Fiat X1-9       Porsche 914-2        Lotus Europa  #>                27.2                31.3                30.0                34.4  #>      Ford Pantera L        Ferrari Dino       Maserati Bora          Volvo 142E  #>                23.8                25.7                23.0                25.4   # More advanced rowwise iteration is available as well by using the # other arguments mtcars_rowwise_window <- slide(mtcars, ~.x, .before = 1, .after = 1) mtcars_rowwise_window[1:3] #> $`Mazda RX4` #>               mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4 #> Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4 #>  #> $`Mazda RX4 Wag` #>                mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 #> Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 #> Datsun 710    22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 #>  #> $`Datsun 710` #>                 mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4 Wag  21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 #> Datsun 710     22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 #> Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 #>   # --------------------------------------------------------------------------- # Cumulative sliding  # Using the special cased value, `Inf`, you can ask `slide()` to pin the # start of the sliding window to the first element, effectively creating # a cumulative window slide(1:5, ~.x, .before = Inf) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 1 2 3 4 #>  #> [[5]] #> [1] 1 2 3 4 5 #>   # Same with `.after`, this creates a window where you start with all of the # elements, but decrease the total number over each iteration slide(1:5, ~.x, .after = Inf) #> [[1]] #> [1] 1 2 3 4 5 #>  #> [[2]] #> [1] 2 3 4 5 #>  #> [[3]] #> [1] 3 4 5 #>  #> [[4]] #> [1] 4 5 #>  #> [[5]] #> [1] 5 #>   # --------------------------------------------------------------------------- # Negative `.before` / `.after`  # `.before` is allowed to be negative, allowing you to \"look forward\" in # your vector. Note that `abs(.before) <= .after` must hold if `.before` is # negative. In this example, we look forward to elements in locations 2 and 3 # but place the result in position 1 in the output. slide(1:5, ~.x, .before = -1, .after = 2) #> [[1]] #> [1] 2 3 #>  #> [[2]] #> [1] 3 4 #>  #> [[3]] #> [1] 4 5 #>  #> [[4]] #> [1] 5 #>  #> [[5]] #> integer(0) #>   # `.after` can be negative as well to \"look backwards\" slide(1:5, ~.x, .before = 2, .after = -1) #> [[1]] #> integer(0) #>  #> [[2]] #> [1] 1 #>  #> [[3]] #> [1] 1 2 #>  #> [[4]] #> [1] 2 3 #>  #> [[5]] #> [1] 3 4 #>   # --------------------------------------------------------------------------- # Removing padding  # If you are looking for a way to remove the `NA` values from something like # this, then it doesn't exist as a built in option. x <- rnorm(10) slide_dbl(x, mean, .before = 3, .step = 2, .complete = TRUE) #>  [1]         NA         NA         NA  0.6905212         NA -0.1819414 #>  [7]         NA -0.8849570         NA -0.5455555  # Adding an option to `slide_dbl()` to remove the `NA` values would destroy # its size stability. Instead, you can use a combination of `slide_dfr()` # to get the start/stop indices with `hop_index_vec()`. i <- seq_along(x) idx <- slide_dfr(   i,   ~data.frame(start = .x[1], stop = .x[length(.x)]),   .before = 3,   .step = 2,   .complete = TRUE )  idx #>   start stop #> 1     1    4 #> 2     3    6 #> 3     5    8 #> 4     7   10  hop_index_vec(x, i, idx$start, idx$stop, mean, .ptype = double()) #> [1]  0.6905212 -0.1819414 -0.8849570 -0.5455555"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide2.html","id":null,"dir":"Reference","previous_headings":"","what":"Slide over multiple inputs simultaneously — slide2","title":"Slide over multiple inputs simultaneously — slide2","text":"variants slide() iterate multiple inputs parallel. parallel sense input processed parallel others, sense multicore computing. functions work similarly map2() pmap() purrr.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slide over multiple inputs simultaneously — slide2","text":"","code":"slide2(   .x,   .y,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  slide2_vec(   .x,   .y,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE,   .ptype = NULL )  slide2_dbl(   .x,   .y,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  slide2_int(   .x,   .y,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  slide2_lgl(   .x,   .y,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  slide2_chr(   .x,   .y,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  slide2_dfr(   .x,   .y,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\") )  slide2_dfc(   .x,   .y,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )  pslide(.l, .f, ..., .before = 0L, .after = 0L, .step = 1L, .complete = FALSE)  pslide_vec(   .l,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE,   .ptype = NULL )  pslide_dbl(   .l,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  pslide_int(   .l,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  pslide_lgl(   .l,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  pslide_chr(   .l,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE )  pslide_dfr(   .l,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\") )  pslide_dfc(   .l,   .f,   ...,   .before = 0L,   .after = 0L,   .step = 1L,   .complete = FALSE,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slide over multiple inputs simultaneously — slide2","text":".x, .y [vector] Vectors iterate . Vectors size 1 recycled. .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. ., .[integer(1) / Inf] number values current element include sliding window. Set Inf select elements current element. Negative values allowed, allows \"look forward\" current element used .value, \"look backwards\" used .. .step [positive integer(1)] number elements shift window forward function calls. .complete [logical(1)] function evaluated complete windows ? FALSE, default, partial computations allowed. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types. .names_to controls input names supplied .... default, input names zapped. string, specifies column input names copied. names often useful identify rows original input. column name supplied ... named, integer column used instead. NULL, input names used row names. .name_repair One \"unique\", \"universal\", \"check_unique\", \"unique_quiet\",  \"universal_quiet\". See vec_as_names() meaning options. vec_rbind(), repair function applied inputs separately. vec_rbind() needs align columns binding rows, thus needs inputs unique names. hand, vec_cbind() applies repair function inputs concatenated together final data frame. Hence vec_cbind() allows permissive minimal names repair. .size , NULL, default, determine number rows vec_cbind() output using tidyverse recycling rules. Alternatively, specify desired number rows, inputs length 1 recycled appropriately. .l [list] list vectors. length .l determines number arguments .f called . .l names, used named arguments .f. Elements .l size 1 recycled.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slide over multiple inputs simultaneously — slide2","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide2.html","id":"slide-","dir":"Reference","previous_headings":"","what":"slide2()","title":"Slide over multiple inputs simultaneously — slide2","text":"vec_size(slide2(.x, .y)) == vec_size_common(.x, .y) vec_ptype(slide2(.x, .y)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide2.html","id":"slide-vec-and-slide-variants","dir":"Reference","previous_headings":"","what":"slide2_vec() and slide2_*() variants","title":"Slide over multiple inputs simultaneously — slide2","text":"vec_size(slide2_vec(.x, .y)) == vec_size_common(.x, .y) vec_size(slide2_vec(.x, .y)[[1]]) == 1L vec_ptype(slide2_vec(.x, .y, .ptype = ptype)) == ptype","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide2.html","id":"pslide-","dir":"Reference","previous_headings":"","what":"pslide()","title":"Slide over multiple inputs simultaneously — slide2","text":"vec_size(pslide(.l)) == vec_size_common(!!! .l) vec_ptype(pslide(.l)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide2.html","id":"pslide-vec-and-pslide-variants","dir":"Reference","previous_headings":"","what":"pslide_vec() and pslide_*() variants","title":"Slide over multiple inputs simultaneously — slide2","text":"vec_size(pslide_vec(.l)) == vec_size_common(!!! .l) vec_size(pslide_vec(.l)[[1]]) == 1L vec_ptype(pslide_vec(.l, .ptype = ptype)) == ptype","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slide over multiple inputs simultaneously — slide2","text":"","code":"# Slide along two inputs at once slide2(1:4, 5:8, ~list(.x, .y), .before = 2) #> [[1]] #> [[1]][[1]] #> [1] 1 #>  #> [[1]][[2]] #> [1] 5 #>  #>  #> [[2]] #> [[2]][[1]] #> [1] 1 2 #>  #> [[2]][[2]] #> [1] 5 6 #>  #>  #> [[3]] #> [[3]][[1]] #> [1] 1 2 3 #>  #> [[3]][[2]] #> [1] 5 6 7 #>  #>  #> [[4]] #> [[4]][[1]] #> [1] 2 3 4 #>  #> [[4]][[2]] #> [1] 6 7 8 #>  #>   # Or, for more than two, use `pslide()` pslide(list(1:4, 5:8, 9:12), ~list(.x, .y, ..3), .before = 2) #> [[1]] #> [[1]][[1]] #> [1] 1 #>  #> [[1]][[2]] #> [1] 5 #>  #> [[1]][[3]] #> [1] 9 #>  #>  #> [[2]] #> [[2]][[1]] #> [1] 1 2 #>  #> [[2]][[2]] #> [1] 5 6 #>  #> [[2]][[3]] #> [1]  9 10 #>  #>  #> [[3]] #> [[3]][[1]] #> [1] 1 2 3 #>  #> [[3]][[2]] #> [1] 5 6 7 #>  #> [[3]][[3]] #> [1]  9 10 11 #>  #>  #> [[4]] #> [[4]][[1]] #> [1] 2 3 4 #>  #> [[4]][[2]] #> [1] 6 7 8 #>  #> [[4]][[3]] #> [1] 10 11 12 #>  #>   # You can even slide along the rows of multiple data frames of # equal size at once set.seed(16) x <- data.frame(a = rnorm(5), b = rnorm(5)) y <- data.frame(c = letters[1:5], d = letters[6:10])  row_return <- function(x_rows, y_rows) {   if (sum(x_rows$a) < 0) {     x_rows   } else {     y_rows   } }  slide2(x, y, row_return, .before = 1, .after = 2) #> [[1]] #>   c d #> 1 a f #> 2 b g #> 3 c h #>  #> [[2]] #>   c d #> 1 a f #> 2 b g #> 3 c h #> 4 d i #>  #> [[3]] #>   c d #> 1 b g #> 2 c h #> 3 d i #> 4 e j #>  #> [[4]] #>   c d #> 1 c h #> 2 d i #> 3 e j #>  #> [[5]] #>           a        b #> 1 -1.444229 1.024973 #> 2  1.147829 0.573142 #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Slide relative to an index — slide_index","title":"Slide relative to an index — slide_index","text":"slide_index() similar slide(), allows secondary .-ndex vector provided. often useful business calculations, want compute rolling computation looking \"3 months back\", approximately equivalent , 3 * 30 days. slide_index() allows irregular window sizes.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slide relative to an index — slide_index","text":"","code":"slide_index(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  slide_index_vec(   .x,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE,   .ptype = NULL )  slide_index_dbl(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  slide_index_int(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  slide_index_lgl(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  slide_index_chr(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  slide_index_dfr(   .x,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\") )  slide_index_dfc(   .x,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slide relative to an index — slide_index","text":".x [vector] vector iterate apply .f . .[vector] index vector determines window sizes. fairly common supply date vector index, required. 3 restrictions index: size index must match size .x, recycled common size. index must increasing vector, duplicate values allowed. index missing values. .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. ., .[vector(1) / function / Inf] vector size 1, represent number values current element .include sliding window. Negative values allowed, allows \"look forward\" current element used .value, \"look backwards\" used .. Boundaries computed elements .- ..+ .. object can added subtracted .+ - can used. example, lubridate period, lubridate::weeks(). Inf, selects elements current element. function, one-sided formula can coerced function, applied .compute boundaries. Note function applied unique values ., rely original length .way. useful applying complex arithmetic operation expressed single - + operation. One example use lubridate::add_with_rollback() avoid invalid dates end month. ranges result applying ..3 restrictions .. .complete [logical(1)] function evaluated complete windows ? FALSE, default, partial computations allowed. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types. .names_to controls input names supplied .... default, input names zapped. string, specifies column input names copied. names often useful identify rows original input. column name supplied ... named, integer column used instead. NULL, input names used row names. .name_repair One \"unique\", \"universal\", \"check_unique\", \"unique_quiet\",  \"universal_quiet\". See vec_as_names() meaning options. vec_rbind(), repair function applied inputs separately. vec_rbind() needs align columns binding rows, thus needs inputs unique names. hand, vec_cbind() applies repair function inputs concatenated together final data frame. Hence vec_cbind() allows permissive minimal names repair. .size , NULL, default, determine number rows vec_cbind() output using tidyverse recycling rules. Alternatively, specify desired number rows, inputs length 1 recycled appropriately.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slide relative to an index — slide_index","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index.html","id":"slide-index-","dir":"Reference","previous_headings":"","what":"slide_index()","title":"Slide relative to an index — slide_index","text":"vec_size(slide_index(.x)) == vec_size(.x) vec_ptype(slide_index(.x)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index.html","id":"slide-index-vec-and-slide-index-variants","dir":"Reference","previous_headings":"","what":"slide_index_vec() and slide_index_*() variants","title":"Slide relative to an index — slide_index","text":"vec_size(slide_index_vec(.x)) == vec_size(.x) vec_size(slide_index_vec(.x)[[1]]) == 1L vec_ptype(slide_index_vec(.x, .ptype = ptype)) == ptype","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slide relative to an index — slide_index","text":"","code":"library(lubridate)  x <- 1:5  # In some cases, sliding over `x` with a strict window size of 2 # will fit your use case. slide(x, ~.x, .before = 1) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 2 3 #>  #> [[4]] #> [1] 3 4 #>  #> [[5]] #> [1] 4 5 #>   # However, if this `i` is a date vector paired with `x`, when computing # rolling calculations you might want to iterate over `x` while # respecting the fact that `i` is an irregular sequence. i <- as.Date(\"2019-08-15\") + c(0:1, 4, 6, 7)  # For example, a \"2 day\" window should not pair `\"2019-08-19\"` and # `\"2019-08-21\"` together, even though they are next to each other in `x`. # `slide_index()` computes the lookback value from the current date in `.i`, # meaning that if you are currently on `\"2019-08-21\"` and look back 1 day, # it will correctly not include `\"2019-08-19\"`. slide_index(i, i, ~.x, .before = 1) #> [[1]] #> [1] \"2019-08-15\" #>  #> [[2]] #> [1] \"2019-08-15\" \"2019-08-16\" #>  #> [[3]] #> [1] \"2019-08-19\" #>  #> [[4]] #> [1] \"2019-08-21\" #>  #> [[5]] #> [1] \"2019-08-21\" \"2019-08-22\" #>   # We could have equivalently used a lubridate period object for this as well, # since `i - lubridate::days(1)` is allowed slide_index(i, i, ~.x, .before = lubridate::days(1)) #> [[1]] #> [1] \"2019-08-15\" #>  #> [[2]] #> [1] \"2019-08-15\" \"2019-08-16\" #>  #> [[3]] #> [1] \"2019-08-19\" #>  #> [[4]] #> [1] \"2019-08-21\" #>  #> [[5]] #> [1] \"2019-08-21\" \"2019-08-22\" #>   # --------------------------------------------------------------------------- # Functions for `.before` and `.after`  # In some cases, it might not be appropriate to compute # `.i - .before` or `.i + .after`, either because there isn't a `-` or `+` # method defined, or because there is an alternative way to perform the # arithmetic. For example, subtracting 1 month with `- months(1)` (using # lubridate) can sometimes land you on an invalid date that doesn't exist. i <- as.Date(c(\"2019-01-31\", \"2019-02-28\", \"2019-03-31\"))  # 2019-03-31 - months(1) = 2019-02-31, which doesn't exist i - months(1) #> [1] \"2018-12-31\" \"2019-01-28\" NA            # These NAs create problems with `slide_index()`, which doesn't allow # missing values in the computed endpoints try(slide_index(i, i, identity, .before = months(1))) #> Error in stop_slider(message, class = c(class, \"slider_error_endpoints\"),  :  #>   Endpoints generated by `.before` cannot be `NA`. #> ℹ They are `NA` at locations: 3.  # In these cases, it is more appropriate to use `%m-%`, # which will snap to the end of the month, at least giving you something # to work with. i %m-% months(1) #> [1] \"2018-12-31\" \"2019-01-28\" \"2019-02-28\"  # To use this as your `.before` or `.after`, supply an anonymous function of # 1 argument that performs the computation slide_index(i, i, identity, .before = ~.x %m-% months(1)) #> [[1]] #> [1] \"2019-01-31\" #>  #> [[2]] #> [1] \"2019-01-31\" \"2019-02-28\" #>  #> [[3]] #> [1] \"2019-02-28\" \"2019-03-31\" #>   # Notice that in the `.after` case, `2019-02-28 %m+% months(1)` doesn't # capture the end of March, so it isn't included in the 2nd result slide_index(i, i, identity, .after = ~.x %m+% months(1)) #> [[1]] #> [1] \"2019-01-31\" \"2019-02-28\" #>  #> [[2]] #> [1] \"2019-02-28\" #>  #> [[3]] #> [1] \"2019-03-31\" #>   # ---------------------------------------------------------------------------  # When `.i` has repeated values, they are always grouped together. i <- c(2017, 2017, 2018, 2019, 2020, 2020) slide_index(i, i, ~.x) #> [[1]] #> [1] 2017 2017 #>  #> [[2]] #> [1] 2017 2017 #>  #> [[3]] #> [1] 2018 #>  #> [[4]] #> [1] 2019 #>  #> [[5]] #> [1] 2020 2020 #>  #> [[6]] #> [1] 2020 2020 #>  slide_index(i, i, ~.x, .after = 1) #> [[1]] #> [1] 2017 2017 2018 #>  #> [[2]] #> [1] 2017 2017 2018 #>  #> [[3]] #> [1] 2018 2019 #>  #> [[4]] #> [1] 2019 2020 2020 #>  #> [[5]] #> [1] 2020 2020 #>  #> [[6]] #> [1] 2020 2020 #>   # --------------------------------------------------------------------------- # Rolling regressions  # Rolling regressions are easy with `slide_index()` because: # - Data frame `.x` values are iterated over rowwise # - The index is respected by using `.i` set.seed(123)  df <- data.frame(   y = rnorm(100),   x = rnorm(100),   i = as.Date(\"2019-08-15\") + c(0, 2, 4, 6:102) # <- irregular )  # 20 day rolling regression. Current day + 19 days back. # Additionally, set `.complete = TRUE` to not compute partial results. regr <- slide_index(df, df$i, ~lm(y ~ x, .x), .before = 19, .complete = TRUE)  regr[16:18] #> [[1]] #> NULL #>  #> [[2]] #>  #> Call: #> lm(formula = y ~ x, data = .x) #>  #> Coefficients: #> (Intercept)            x   #>      0.3257       0.2067   #>  #>  #> [[3]] #>  #> Call: #> lm(formula = y ~ x, data = .x) #>  #> Coefficients: #> (Intercept)            x   #>      0.2574       0.2632   #>  #>   # The first 16 slots are NULL because there is no possible way to # look back 19 days from the 16th index position and construct a full # window. But on the 17th index position, `\"\"2019-09-03\"`, if we look # back 19 days we get to `\"\"2019-08-15\"`, which is the same value as # `i[1]` so a full window can be constructed. df$i[16] - 19 >= df$i[1] # FALSE #> [1] FALSE df$i[17] - 19 >= df$i[1] # TRUE #> [1] TRUE  # --------------------------------------------------------------------------- # Accessing the current index value  # A very simplistic version of `purrr::map2()` fake_map2 <- function(.x, .y, .f, ...) {   Map(.f, .x, .y, ...) }  # Occasionally you need to access the index value that you are currently on. # This is generally not possible with a single call to `slide_index()`, but # can be easily accomplished by following up a `slide_index()` call with a # `purrr::map2()`. In this example, we want to use the distance from the # current index value (in days) as a multiplier on `x`. Values further # away from the current date get a higher multiplier. set.seed(123)  # 25 random days past 2000-01-01 i <- sort(as.Date(\"2000-01-01\") + sample(100, 25))  df <- data.frame(i = i, x = rnorm(25))  weight_by_distance <- function(df, i) {   df$weight = abs(as.integer(df$i - i))   df$x_weighted = df$x * df$weight   df }  # Use `slide_index()` to just generate the rolling data. # Here we take the current date + 5 days before + 5 days after. dfs <- slide_index(df, df$i, ~.x, .before = 5, .after = 5)  # Follow up with a `map2()` with `i` as the second input. # This allows you to track the current `i` value and weight accordingly. result <- fake_map2(dfs, df$i, weight_by_distance)  head(result) #> [[1]] #>            i          x weight x_weighted #> 1 2000-01-08 -0.2179749      0   0.000000 #> 2 2000-01-10 -1.0260044      2  -2.052009 #>  #> [[2]] #>            i          x weight x_weighted #> 1 2000-01-08 -0.2179749      2 -0.4359498 #> 2 2000-01-10 -1.0260044      0  0.0000000 #> 3 2000-01-15 -0.7288912      5 -3.6444561 #>  #> [[3]] #>            i          x weight x_weighted #> 1 2000-01-10 -1.0260044      5 -5.1300222 #> 2 2000-01-15 -0.7288912      0  0.0000000 #> 3 2000-01-16 -0.6250393      1 -0.6250393 #>  #> [[4]] #>            i          x weight x_weighted #> 1 2000-01-15 -0.7288912      1 -0.7288912 #> 2 2000-01-16 -0.6250393      0  0.0000000 #>  #> [[5]] #>            i         x weight x_weighted #> 1 2000-01-26 -1.686693      0   0.000000 #> 2 2000-01-27  0.837787      1   0.837787 #>  #> [[6]] #>            i          x weight x_weighted #> 1 2000-01-26 -1.6866933      1 -1.6866933 #> 2 2000-01-27  0.8377870      0  0.0000000 #> 3 2000-02-01  0.1533731      5  0.7668656 #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index2.html","id":null,"dir":"Reference","previous_headings":"","what":"Slide along multiples inputs simultaneously relative to an index — slide_index2","title":"Slide along multiples inputs simultaneously relative to an index — slide_index2","text":"slide_index2() pslide_index() represent combination slide2() pslide() slide_index(), allowing iterate multiple vectors relative .-ndex.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slide along multiples inputs simultaneously relative to an index — slide_index2","text":"","code":"slide_index2(.x, .y, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  slide_index2_vec(   .x,   .y,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE,   .ptype = NULL )  slide_index2_dbl(   .x,   .y,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_index2_int(   .x,   .y,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_index2_lgl(   .x,   .y,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_index2_chr(   .x,   .y,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_index2_dfr(   .x,   .y,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\") )  slide_index2_dfc(   .x,   .y,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )  pslide_index(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  pslide_index_vec(   .l,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE,   .ptype = NULL )  pslide_index_dbl(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  pslide_index_int(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  pslide_index_lgl(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  pslide_index_chr(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)  pslide_index_dfr(   .l,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\") )  pslide_index_dfc(   .l,   .i,   .f,   ...,   .before = 0L,   .after = 0L,   .complete = FALSE,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slide along multiples inputs simultaneously relative to an index — slide_index2","text":".x, .y [vector] Vectors iterate . Vectors size 1 recycled. .[vector] index vector determines window sizes. fairly common supply date vector index, required. 3 restrictions index: size index must match size .x, recycled common size. index must increasing vector, duplicate values allowed. index missing values. .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. ., .[vector(1) / function / Inf] vector size 1, represent number values current element .include sliding window. Negative values allowed, allows \"look forward\" current element used .value, \"look backwards\" used .. Boundaries computed elements .- ..+ .. object can added subtracted .+ - can used. example, lubridate period, lubridate::weeks(). Inf, selects elements current element. function, one-sided formula can coerced function, applied .compute boundaries. Note function applied unique values ., rely original length .way. useful applying complex arithmetic operation expressed single - + operation. One example use lubridate::add_with_rollback() avoid invalid dates end month. ranges result applying ..3 restrictions .. .complete [logical(1)] function evaluated complete windows ? FALSE, default, partial computations allowed. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types. .names_to controls input names supplied .... default, input names zapped. string, specifies column input names copied. names often useful identify rows original input. column name supplied ... named, integer column used instead. NULL, input names used row names. .name_repair One \"unique\", \"universal\", \"check_unique\", \"unique_quiet\",  \"universal_quiet\". See vec_as_names() meaning options. vec_rbind(), repair function applied inputs separately. vec_rbind() needs align columns binding rows, thus needs inputs unique names. hand, vec_cbind() applies repair function inputs concatenated together final data frame. Hence vec_cbind() allows permissive minimal names repair. .size , NULL, default, determine number rows vec_cbind() output using tidyverse recycling rules. Alternatively, specify desired number rows, inputs length 1 recycled appropriately. .l [list] list vectors. length .l determines number arguments .f called . .l names, used named arguments .f. Elements .l size 1 recycled.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slide along multiples inputs simultaneously relative to an index — slide_index2","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index2.html","id":"slide-index-","dir":"Reference","previous_headings":"","what":"slide_index2()","title":"Slide along multiples inputs simultaneously relative to an index — slide_index2","text":"vec_size(slide_index2(.x, .y)) == vec_size_common(.x, .y) vec_ptype(slide_index2(.x, .y)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index2.html","id":"slide-index-vec-and-slide-index-variants","dir":"Reference","previous_headings":"","what":"slide_index2_vec() and slide_index2_*() variants","title":"Slide along multiples inputs simultaneously relative to an index — slide_index2","text":"vec_size(slide_index2_vec(.x, .y)) == vec_size_common(.x, .y) vec_size(slide_index2_vec(.x, .y)[[1]]) == 1L vec_ptype(slide_index2_vec(.x, .y, .ptype = ptype)) == ptype","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index2.html","id":"pslide-index-","dir":"Reference","previous_headings":"","what":"pslide_index()","title":"Slide along multiples inputs simultaneously relative to an index — slide_index2","text":"vec_size(pslide_index(.l)) == vec_size_common(!!! .l) vec_ptype(pslide_index(.l)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index2.html","id":"pslide-index-vec-and-pslide-index-variants","dir":"Reference","previous_headings":"","what":"pslide_index_vec() and pslide_index_*() variants","title":"Slide along multiples inputs simultaneously relative to an index — slide_index2","text":"vec_size(pslide_index_vec(.l)) == vec_size_common(!!! .l) vec_size(pslide_index_vec(.l)[[1]]) == 1L vec_ptype(pslide_index_vec(.l, .ptype = ptype)) == ptype","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_index2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slide along multiples inputs simultaneously relative to an index — slide_index2","text":"","code":"# Notice that `i` is an irregular index! x <- 1:5 y <- 6:10 i <- as.Date(\"2019-08-15\") + c(0:1, 4, 6, 7)  # When we slide over `i` looking back 1 day, the irregularity is respected. # When there is a gap in dates, only 2 values are returned (one from # `x` and one from `y`), otherwise, 4 values are returned. slide_index2(x, y, i, ~c(.x, .y), .before = 1) #> [[1]] #> [1] 1 6 #>  #> [[2]] #> [1] 1 2 6 7 #>  #> [[3]] #> [1] 3 8 #>  #> [[4]] #> [1] 4 9 #>  #> [[5]] #> [1]  4  5  9 10 #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Slide relative to an index chunked by period — slide_period","title":"Slide relative to an index chunked by period — slide_period","text":"slide_period() breaks .-ndex .period, uses define indices slide .x . can useful , say, sliding daily data monthly chunks. underlying engine breaking .warp::warp_distance(). need information .period types, best place look.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slide relative to an index chunked by period — slide_period","text":"","code":"slide_period(   .x,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period_vec(   .x,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE,   .ptype = NULL )  slide_period_dbl(   .x,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period_int(   .x,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period_lgl(   .x,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period_chr(   .x,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period_dfr(   .x,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\") )  slide_period_dfc(   .x,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slide relative to an index chunked by period — slide_period","text":".x [vector] vector iterate apply .f . .[Date / POSIXct / POSIXlt] datetime index break periods. 3 restrictions index: size index must match size .x, recycled common size. index must increasing vector, duplicate values allowed. index missing values. .period [character(1)] string defining period group . Valid inputs can roughly broken : \"year\", \"quarter\", \"month\", \"week\", \"day\" \"hour\", \"minute\", \"second\", \"millisecond\" \"yweek\", \"mweek\" \"yday\", \"mday\" .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. .every [positive integer(1)] number periods group together. example, period set \"year\" every value 2, years 1970 1971 placed group. .origin [Date(1) / POSIXct(1) / POSIXlt(1) / NULL] reference date time value. default left NULL epoch time 1970-01-01 00:00:00, time zone index. generally used define anchor time count , relevant every value > 1. ., .[integer(1) / Inf] number values current element include sliding window. Set Inf select elements current element. Negative values allowed, allows \"look forward\" current element used .value, \"look backwards\" used .. .complete [logical(1)] function evaluated complete windows ? FALSE, default, partial computations allowed. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types. .names_to controls input names supplied .... default, input names zapped. string, specifies column input names copied. names often useful identify rows original input. column name supplied ... named, integer column used instead. NULL, input names used row names. .name_repair One \"unique\", \"universal\", \"check_unique\", \"unique_quiet\",  \"universal_quiet\". See vec_as_names() meaning options. vec_rbind(), repair function applied inputs separately. vec_rbind() needs align columns binding rows, thus needs inputs unique names. hand, vec_cbind() applies repair function inputs concatenated together final data frame. Hence vec_cbind() allows permissive minimal names repair. .size , NULL, default, determine number rows vec_cbind() output using tidyverse recycling rules. Alternatively, specify desired number rows, inputs length 1 recycled appropriately.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slide relative to an index chunked by period — slide_period","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period.html","id":"slide-period-","dir":"Reference","previous_headings":"","what":"slide_period()","title":"Slide relative to an index chunked by period — slide_period","text":"vec_size(slide_period(.x)) == vec_size(unique(warp::warp_distance(.))) vec_ptype(slide_period(.x)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period.html","id":"slide-period-vec-and-slide-period-variants","dir":"Reference","previous_headings":"","what":"slide_period_vec() and slide_period_*() variants","title":"Slide relative to an index chunked by period — slide_period","text":"vec_size(slide_period_vec(.x)) == vec_size(unique(warp::warp_distance(.))) vec_size(slide_period_vec(.x)[[1]]) == 1L vec_ptype(slide_period_vec(.x, .ptype = ptype)) == ptype","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slide relative to an index chunked by period — slide_period","text":"","code":"i <- as.Date(\"2019-01-28\") + 0:5  # Split `i` into 2-day periods to apply `.f` to slide_period(i, i, \"day\", identity, .every = 2) #> [[1]] #> [1] \"2019-01-28\" \"2019-01-29\" #>  #> [[2]] #> [1] \"2019-01-30\" \"2019-01-31\" #>  #> [[3]] #> [1] \"2019-02-01\" \"2019-02-02\" #>   # Or into 1-month periods slide_period(i, i, \"month\", identity) #> [[1]] #> [1] \"2019-01-28\" \"2019-01-29\" \"2019-01-30\" \"2019-01-31\" #>  #> [[2]] #> [1] \"2019-02-01\" \"2019-02-02\" #>   # Now select: # - The current 2-day period # - Plus 1 2-day period before the current one slide_period(i, i, \"day\", identity, .every = 2, .before = 1) #> [[1]] #> [1] \"2019-01-28\" \"2019-01-29\" #>  #> [[2]] #> [1] \"2019-01-28\" \"2019-01-29\" \"2019-01-30\" \"2019-01-31\" #>  #> [[3]] #> [1] \"2019-01-30\" \"2019-01-31\" \"2019-02-01\" \"2019-02-02\" #>   # Alter the `origin` to control the reference date for # how the 2-day groups are formed origin <- as.Date(\"2019-01-29\") slide_period(i, i, \"day\", identity, .every = 2, .origin = origin) #> [[1]] #> [1] \"2019-01-28\" #>  #> [[2]] #> [1] \"2019-01-29\" \"2019-01-30\" #>  #> [[3]] #> [1] \"2019-01-31\" \"2019-02-01\" #>  #> [[4]] #> [1] \"2019-02-02\" #>   # This can be useful for, say, monthly averages daily_sales <- c(2, 5, 3, 6, 9, 4) slide_period_dbl(daily_sales, i, \"month\", mean) #> [1] 4.0 6.5  # If you need the index, slide over and return a data frame sales_df <- data.frame(i = i, sales = daily_sales)  slide_period_dfr(   sales_df,   sales_df$i,   \"month\",   ~data.frame(      i = max(.x$i),      sales = mean(.x$sales)    ) ) #>            i sales #> 1 2019-01-31   4.0 #> 2 2019-02-02   6.5  # One of the most unique features about `slide_period()` is that it is # aware of how far apart elements of `.i` are in the `.period` you are # interested in. For example, if you do a monthly slide with `i2`, selecting # the current month and 1 month before it, then it will recognize that # `2019-02-01` and `2019-04-01` are not beside each other, and it won't # group them together. i2 <- as.Date(c(\"2019-01-01\", \"2019-02-01\", \"2019-04-01\", \"2019-05-01\"))  slide_period(i2, i2, \"month\", identity, .before = 1) #> [[1]] #> [1] \"2019-01-01\" #>  #> [[2]] #> [1] \"2019-01-01\" \"2019-02-01\" #>  #> [[3]] #> [1] \"2019-04-01\" #>  #> [[4]] #> [1] \"2019-04-01\" \"2019-05-01\" #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period2.html","id":null,"dir":"Reference","previous_headings":"","what":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","title":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","text":"slide_period2() pslide_period() represent combination slide2() pslide() slide_period(), allowing slide multiple vectors , using indices defined breaking .-ndex .period.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","text":"","code":"slide_period2(   .x,   .y,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period2_vec(   .x,   .y,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE,   .ptype = NULL )  slide_period2_dbl(   .x,   .y,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period2_int(   .x,   .y,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period2_lgl(   .x,   .y,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period2_chr(   .x,   .y,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  slide_period2_dfr(   .x,   .y,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\") )  slide_period2_dfc(   .x,   .y,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )  pslide_period(   .l,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  pslide_period_vec(   .l,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE,   .ptype = NULL )  pslide_period_dbl(   .l,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  pslide_period_int(   .l,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  pslide_period_lgl(   .l,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  pslide_period_chr(   .l,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE )  pslide_period_dfr(   .l,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\") )  pslide_period_dfc(   .l,   .i,   .period,   .f,   ...,   .every = 1L,   .origin = NULL,   .before = 0L,   .after = 0L,   .complete = FALSE,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","text":".x, .y [vector] Vectors iterate . Vectors size 1 recycled. .[Date / POSIXct / POSIXlt] datetime index break periods. 3 restrictions index: size index must match size .x, recycled common size. index must increasing vector, duplicate values allowed. index missing values. .period [character(1)] string defining period group . Valid inputs can roughly broken : \"year\", \"quarter\", \"month\", \"week\", \"day\" \"hour\", \"minute\", \"second\", \"millisecond\" \"yweek\", \"mweek\" \"yday\", \"mday\" .f [function / formula] function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. ... Additional arguments passed mapped function. .every [positive integer(1)] number periods group together. example, period set \"year\" every value 2, years 1970 1971 placed group. .origin [Date(1) / POSIXct(1) / POSIXlt(1) / NULL] reference date time value. default left NULL epoch time 1970-01-01 00:00:00, time zone index. generally used define anchor time count , relevant every value > 1. ., .[integer(1) / Inf] number values current element include sliding window. Set Inf select elements current element. Negative values allowed, allows \"look forward\" current element used .value, \"look backwards\" used .. .complete [logical(1)] function evaluated complete windows ? FALSE, default, partial computations allowed. .ptype [vector(0) / NULL] prototype corresponding type output. NULL, default, output type determined computing common type across results calls .f. supplied, result call .f cast type, final output type. getOption(\"vctrs.no_guessing\") TRUE, .ptype must supplied. way make production code demand fixed types. .names_to controls input names supplied .... default, input names zapped. string, specifies column input names copied. names often useful identify rows original input. column name supplied ... named, integer column used instead. NULL, input names used row names. .name_repair One \"unique\", \"universal\", \"check_unique\", \"unique_quiet\",  \"universal_quiet\". See vec_as_names() meaning options. vec_rbind(), repair function applied inputs separately. vec_rbind() needs align columns binding rows, thus needs inputs unique names. hand, vec_cbind() applies repair function inputs concatenated together final data frame. Hence vec_cbind() allows permissive minimal names repair. .size , NULL, default, determine number rows vec_cbind() output using tidyverse recycling rules. Alternatively, specify desired number rows, inputs length 1 recycled appropriately. .l [list] list vectors. length .l determines number arguments .f called . .l names, used named arguments .f. Elements .l size 1 recycled.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","text":"vector fulfilling following invariants:","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period2.html","id":"slide-period-","dir":"Reference","previous_headings":"","what":"slide_period2()","title":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","text":"vec_size(slide_period2(.x, .y)) == vec_size(unique(warp::warp_distance(.))) vec_ptype(slide_period2(.x, .y)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period2.html","id":"slide-period-vec-and-slide-period-variants","dir":"Reference","previous_headings":"","what":"slide_period2_vec() and slide_period2_*() variants","title":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","text":"vec_size(slide_period2_vec(.x, .y)) == vec_size(unique(warp::warp_distance(.))) vec_size(slide_period2_vec(.x, .y)[[1]]) == 1L vec_ptype(slide_period2_vec(.x, .y, .ptype = ptype)) == ptype","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period2.html","id":"pslide-period-","dir":"Reference","previous_headings":"","what":"pslide_period()","title":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","text":"vec_size(pslide_period(.l)) == vec_size(unique(warp::warp_distance(.))) vec_ptype(pslide_period(.l)) == list()","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period2.html","id":"pslide-period-vec-and-pslide-period-variants","dir":"Reference","previous_headings":"","what":"pslide_period_vec() and pslide_period_*() variants","title":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","text":"vec_size(pslide_period_vec(.l)) == vec_size(unique(warp::warp_distance(.))) vec_size(pslide_period_vec(.l)[[1]]) == 1L vec_ptype(pslide_period_vec(.l, .ptype = ptype)) == ptype","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/slide_period2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slide along multiple inputs simultaneously relative to an index chunked by period — slide_period2","text":"","code":"i <- as.Date(\"2019-01-28\") + 0:5  slide_period2(   .x = 1:6,   .y = i,   .i = i,   .period = \"month\",   .f = ~data.frame(x = .x, i = .y) ) #> [[1]] #>   x          i #> 1 1 2019-01-28 #> 2 2 2019-01-29 #> 3 3 2019-01-30 #> 4 4 2019-01-31 #>  #> [[2]] #>   x          i #> 1 5 2019-02-01 #> 2 6 2019-02-02 #>   pslide_period(   .l = list(1:6, 7:12, i),   .i = i,   .period = \"month\",   .f = ~data.frame(x = .x, y = .y, i = ..3) ) #> [[1]] #>   x  y          i #> 1 1  7 2019-01-28 #> 2 2  8 2019-01-29 #> 3 3  9 2019-01-30 #> 4 4 10 2019-01-31 #>  #> [[2]] #>   x  y          i #> 1 5 11 2019-02-01 #> 2 6 12 2019-02-02 #>"},{"path":"https://davisvaughan.github.io/slider/dev/reference/slider-package.html","id":null,"dir":"Reference","previous_headings":"","what":"slider: Sliding Window Functions — slider-package","title":"slider: Sliding Window Functions — slider-package","text":"Provides type-stable rolling window functions R data type. Cumulative expanding windows also supported. advanced usage, index can used secondary vector defines sliding windows created.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/slider-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"slider: Sliding Window Functions — slider-package","text":"Maintainer: Davis Vaughan davis@rstudio.com contributors: RStudio [copyright holder, funder]","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-index.html","id":null,"dir":"Reference","previous_headings":"","what":"Specialized sliding functions relative to an index — summary-index","title":"Specialized sliding functions relative to an index — summary-index","text":"functions specialized variants common ways slide_index() generally used. Notably, slide_index_sum() can used rolling sums relative index (like Date column), slide_index_mean() can used rolling averages. specialized variants much faster memory efficient using otherwise equivalent call constructed slide_index_dbl() slide_index_lgl(), especially wide window.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specialized sliding functions relative to an index — summary-index","text":"","code":"slide_index_sum(   x,   i,   ...,   before = 0L,   after = 0L,   complete = FALSE,   na_rm = FALSE )  slide_index_prod(   x,   i,   ...,   before = 0L,   after = 0L,   complete = FALSE,   na_rm = FALSE )  slide_index_mean(   x,   i,   ...,   before = 0L,   after = 0L,   complete = FALSE,   na_rm = FALSE )  slide_index_min(   x,   i,   ...,   before = 0L,   after = 0L,   complete = FALSE,   na_rm = FALSE )  slide_index_max(   x,   i,   ...,   before = 0L,   after = 0L,   complete = FALSE,   na_rm = FALSE )  slide_index_all(   x,   i,   ...,   before = 0L,   after = 0L,   complete = FALSE,   na_rm = FALSE )  slide_index_any(   x,   i,   ...,   before = 0L,   after = 0L,   complete = FALSE,   na_rm = FALSE )"},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specialized sliding functions relative to an index — summary-index","text":"x [vector] vector compute sliding function . sliding sum, mean, prod, min, max, x cast double vector vctrs::vec_cast(). sliding , x cast logical vector vctrs::vec_cast(). [vector] index vector determines window sizes. fairly common supply date vector index, required. 3 restrictions index: size index must match size .x, recycled common size. index must increasing vector, duplicate values allowed. index missing values. ... dots future extensions must empty. , [vector(1) / function / Inf] vector size 1, represent number values current element .include sliding window. Negative values allowed, allows \"look forward\" current element used .value, \"look backwards\" used .. Boundaries computed elements .- ..+ .. object can added subtracted .+ - can used. example, lubridate period, lubridate::weeks(). Inf, selects elements current element. function, one-sided formula can coerced function, applied .compute boundaries. Note function applied unique values ., rely original length .way. useful applying complex arithmetic operation expressed single - + operation. One example use lubridate::add_with_rollback() avoid invalid dates end month. ranges result applying ..3 restrictions .. complete [logical(1)] function evaluated complete windows ? FALSE, default, partial computations allowed. na_rm [logical(1)] missing values removed computation?","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specialized sliding functions relative to an index — summary-index","text":"vector size x containing result applying summary function sliding windows. sliding sum, mean, prod, min, max, double vector returned. sliding , logical vector returned.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specialized sliding functions relative to an index — summary-index","text":"details implementation, see help page slide_sum().","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specialized sliding functions relative to an index — summary-index","text":"","code":"x <- c(1, 5, 3, 2, 6, 10) i <- as.Date(\"2019-01-01\") + c(0, 1, 3, 4, 6, 8)  # `slide_index_sum()` can be used for rolling sums relative to an index, # allowing you to \"respect gaps\" in your series. Notice that the rolling # sum in row 3 is only computed from `2019-01-04` and `2019-01-02` since # `2019-01-01` is more than two days before the current date. data.frame(   i = i,   x = x,   roll = slide_index_sum(x, i, before = 2) ) #>            i  x roll #> 1 2019-01-01  1    1 #> 2 2019-01-02  5    6 #> 3 2019-01-04  3    8 #> 4 2019-01-05  2    5 #> 5 2019-01-07  6    8 #> 6 2019-01-09 10   16  # `slide_index_mean()` can be used for rolling averages slide_index_mean(x, i, before = 2) #> [1] 1.0 3.0 4.0 2.5 4.0 8.0  # Only evaluate the sum on windows that have the potential to be complete slide_index_sum(x, i, before = 2, after = 1, complete = TRUE) #> [1] NA NA 10  5  8 NA"},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-slide.html","id":null,"dir":"Reference","previous_headings":"","what":"Specialized sliding functions — summary-slide","title":"Specialized sliding functions — summary-slide","text":"functions specialized variants common ways slide() generally used. Notably, slide_sum() can used rolling sums, slide_mean() can used rolling averages. specialized variants much faster memory efficient using otherwise equivalent call constructed slide_dbl() slide_lgl(), especially wide window.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-slide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specialized sliding functions — summary-slide","text":"","code":"slide_sum(   x,   ...,   before = 0L,   after = 0L,   step = 1L,   complete = FALSE,   na_rm = FALSE )  slide_prod(   x,   ...,   before = 0L,   after = 0L,   step = 1L,   complete = FALSE,   na_rm = FALSE )  slide_mean(   x,   ...,   before = 0L,   after = 0L,   step = 1L,   complete = FALSE,   na_rm = FALSE )  slide_min(   x,   ...,   before = 0L,   after = 0L,   step = 1L,   complete = FALSE,   na_rm = FALSE )  slide_max(   x,   ...,   before = 0L,   after = 0L,   step = 1L,   complete = FALSE,   na_rm = FALSE )  slide_all(   x,   ...,   before = 0L,   after = 0L,   step = 1L,   complete = FALSE,   na_rm = FALSE )  slide_any(   x,   ...,   before = 0L,   after = 0L,   step = 1L,   complete = FALSE,   na_rm = FALSE )"},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-slide.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specialized sliding functions — summary-slide","text":"x [vector] vector compute sliding function . sliding sum, mean, prod, min, max, x cast double vector vctrs::vec_cast(). sliding , x cast logical vector vctrs::vec_cast(). ... dots future extensions must empty. , [integer(1) / Inf] number values current element include sliding window. Set Inf select elements current element. Negative values allowed, allows \"look forward\" current element used .value, \"look backwards\" used .. step [positive integer(1)] number elements shift window forward function calls. complete [logical(1)] function evaluated complete windows ? FALSE, default, partial computations allowed. na_rm [logical(1)] missing values removed computation?","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-slide.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specialized sliding functions — summary-slide","text":"vector size x containing result applying summary function sliding windows. sliding sum, mean, prod, min, max, double vector returned. sliding , logical vector returned.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-slide.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specialized sliding functions — summary-slide","text":"Note functions generic respect method dispatch corresponding summary function (.e. base::sum(), base::mean()). Input always cast double logical vector using vctrs::vec_cast(), internal method computing summary function used. Due structure segment trees, slide_mean() perform \"two pass\" mean mean() (intention second pass perform floating point error correction). , may small differences slide_mean(x) slide_dbl(x, mean) cases.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-slide.html","id":"implementation","dir":"Reference","previous_headings":"","what":"Implementation","title":"Specialized sliding functions — summary-slide","text":"variants implemented using data structure known segment tree, allows extremely fast repeated range queries without loss precision. One alternative segment trees directly recompute summary function full window. done using, example, slide_dbl(x, sum). extremely slow large window sizes wastes lot effort recomputing nearly information window. can made slightly faster moving sum C avoid intermediate allocations, still fairly slow. second alternative use online algorithm, uses information previous window compute next window. extremely fast, requiring single pass data, often suffer numerical instability issues. Segment trees attempt reconcile performance issues direct approach numerical issues online approach. performance segment trees quite fast online algorithms, close enough usable large data sets without issues. Unlike online algorithms, segment trees suffer extra numerical instability issues.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-slide.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Specialized sliding functions — summary-slide","text":"Leis, Kundhikanjana, Kemper, Neumann (2015). \"Efficient Processing Window Functions Analytical SQL Queries\". https://dl.acm.org/doi/10.14778/2794367.2794375","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/slider/dev/reference/summary-slide.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specialized sliding functions — summary-slide","text":"","code":"x <- c(1, 5, 3, 2, 6, 10)  # `slide_sum()` can be used for rolling sums. # The following are equivalent, but `slide_sum()` is much faster. slide_sum(x, before = 2) #> [1]  1  6  9 10 11 18 slide_dbl(x, sum, .before = 2) #> [1]  1  6  9 10 11 18  # `slide_mean()` can be used for rolling averages slide_mean(x, before = 2) #> [1] 1.000000 3.000000 3.000000 3.333333 3.666667 6.000000  # Only evaluate the sum on complete windows slide_sum(x, before = 2, after = 1, complete = TRUE) #> [1] NA NA 11 16 21 NA  # Skip every other calculation slide_sum(x, before = 2, step = 2) #> [1]  1 NA  9 NA 11 NA"},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-development-version","dir":"Changelog","previous_headings":"","what":"slider (development version)","title":"slider (development version)","text":"Removed ellipsis favor using equivalent functions rlang (#185). New slider_plus() slider_minus() developer facing helpers allow package authors register custom double dispatch methods override default computation .- ..+ .generating index bounds internally. intended allow clock almanac packages register methods custom types can used natively slider (#91). Index (.) types aren’t explicitly understood vctrs now handled slightly better (#182). slide_index_*() hop_index_*() families now use vctrs::vec_rank() internally compute dense rank, little faster previous home grown approach (#177). Removed R_forceAndCall() fallback now R >=3.4.0 required (#172). Fixed -Wstrict-prototypes warnings requested CRAN (#173). Bumped minimal version R >=3.4.0 align tidyverse standards. Fixed redirecting URLs. Bumped minimal version rlang >=1.0.6 vctrs >=0.5.0 (#165, #174).","code":""},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-022","dir":"Changelog","previous_headings":"","what":"slider 0.2.2","title":"slider 0.2.2","text":"CRAN release: 2021-07-01 Updated internal usage vec_order() prepare breaking change vctrs (#153).","code":""},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-021","dir":"Changelog","previous_headings":"","what":"slider 0.2.1","title":"slider 0.2.1","text":"CRAN release: 2021-03-23 Fixed C alignment issue detected CRAN’s USBAN machine related allocating vectors long double. Fixed test relied strongly size C type, long double, can vary across platforms (#147). Fixed sync vignette entry (#148).","code":""},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-020","dir":"Changelog","previous_headings":"","what":"slider 0.2.0","title":"slider 0.2.0","text":"CRAN release: 2021-03-18 New family fast specialized sliding functions: slide_sum(), slide_index_sum(): rolling sums slide_mean(), slide_index_mean(): rolling averages slide_prod(), slide_index_prod(): rolling products slide_min(), slide_index_min(): rolling minimums slide_max(), slide_index_max(): rolling maximums slide_any(), slide_index_any(): rolling slide_all(), slide_index_all(): rolling slide_index_*() family now allows ..functions 1 argument (index) compute boundaries sliding window. can extremely useful default, computes .- ..+ ., applicable correct needs. One use case set .= ~.x %m-% months(1) rather .= months(1) perform 1 month rolling window way won’t generate NA values invalid dates (like 1 month 2019-03-31) (#139). slide_index_*() family undergone internal changes make compatible custom vctrs classes provided index (.), date-time classes clock package (#133, #130). slide_index_*() family, now required .- ..+ .castable .vctrs::vec_cast(). Similarly, hop_index_*() family, .starts .stops must castable .(#132). New vignette, vignette(\"tsibble\"), explaining transition tsibble slider (#128). vignette(\"rowwise\") updated use cur_data() dplyr 1.0.0, makes significantly easier rolling operations data frames (like rolling regressions) using slider dplyr pipeline.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-015","dir":"Changelog","previous_headings":"","what":"slider 0.1.5","title":"slider 0.1.5","text":"CRAN release: 2020-07-21 slide_period() friends slightly better handling size zero input .complete = TRUE (#111). Better error messages NA input ., ., .step .complete added (#110). instances possibly unsafe C protection usage fixed (#112). Tests updated use numeric values vctrs::new_date() constructor (#113).","code":""},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-014","dir":"Changelog","previous_headings":"","what":"slider 0.1.4","title":"slider 0.1.4","text":"CRAN release: 2020-05-28 followup change slider 0.1.3, edge cases size zero input hop() also fixed. C code refactored less reliant vctrs internals.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-013","dir":"Changelog","previous_headings":"","what":"slider 0.1.3","title":"slider 0.1.3","text":"CRAN release: 2020-05-14 Updated stay compatible vctrs 0.3.0. edge cases size zero input index functions fixed. default .names_to argument *_dfr() variants updated rlang::zap() match default function passed , vctrs::vec_rbind(). *_vec() variants now maintain size stability auto-simplifying (.e. .ptype = NULL) (#78, #93). hop() variants longer place names .x output. size guarantee output, size .x can different size output, meaning names might line . also affects slide_period(), implemented using hop() variant (#75). data frames containing row names, slide() variants now copy row names onto output. implicit benefit vctrs gaining better support data frame row names.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-012","dir":"Changelog","previous_headings":"","what":"slider 0.1.2","title":"slider 0.1.2","text":"CRAN release: 2020-03-10 Updated stay compatible latest version vctrs.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-011","dir":"Changelog","previous_headings":"","what":"slider 0.1.1","title":"slider 0.1.1","text":"CRAN release: 2020-02-23 Fixed “multiple definition” C issue compiling gcc10.","code":""},{"path":"https://davisvaughan.github.io/slider/dev/news/index.html","id":"slider-010","dir":"Changelog","previous_headings":"","what":"slider 0.1.0","title":"slider 0.1.0","text":"CRAN release: 2020-02-06 Added NEWS.md file track changes package.","code":""}]
